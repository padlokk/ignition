#!/usr/bin/env bash
# Generated by build.sh on Mon Sep  8 02:51:32 PM MDT 2025
# Auto-assembled from numbered modules: 01_header.sh 02_config.sh 03_stderr.sh 04_helpers.sh 05_printers.sh 06_api.sh 07_core.sh 08_main.sh 09_footer.sh
# === 01_header.sh ===
#!/usr/bin/env bash
#
#  ____            _  _            _    
# |  _ \ __ _  __| || | ___   ___| | __
# | |_) / _` |/ _` || |/ _ \ / __| |/ /
# |  __/ (_| | (_| || | (_) | (__|   < 
# |_|   \__,_|\__,_||_|\___/ \___|_|\_\
#                                     
# Git Repository Security Orchestrator
#
# name: padlock
# version: 1.6.1
# author: fx-padlock
# description: Age-based encryption for git repositories with locker pattern
# 
# portable: age, age-keygen, git, tar, find, curl, head, tail, grep, awk, sed
# builtins: printf, read, local, declare, case, if, for, while, source, export

set -euo pipefail

# === 02_config.sh ===
################################################################################
# Configuration & Bootstrap
################################################################################

# XDG+ Environment (use env first, fallback to local)
XDG_ETC_HOME="${XDG_ETC_HOME:-$HOME/.local/etc}"
XDG_LIB_HOME="${XDG_LIB_HOME:-$HOME/.local/lib}"
XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/data}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

# Script identity
readonly SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
readonly SCRIPT_NAME="$(basename "$SCRIPT_PATH")"
readonly SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Padlock configuration - extract version from header
readonly PADLOCK_VERSION="$(grep "^# version:" "$SCRIPT_PATH" 2>/dev/null | sed 's/^# version:[[:space:]]*//' || echo "unknown")"
readonly PADLOCK_ETC="$XDG_ETC_HOME/padlock"
readonly PADLOCK_KEYS="$PADLOCK_ETC/keys"
readonly PADLOCK_GLOBAL_KEY="$PADLOCK_KEYS/global.key"
readonly PADLOCK_CONFIG="$PADLOCK_ETC/config"

# Runtime paths (determined at execution)
REPO_ROOT=""
LOCKER_DIR=""
LOCKER_BLOB=""
LOCKER_CONFIG=""

# Options (set by options() function)
opt_debug=0
opt_trace=0
opt_quiet=0
opt_force=0
opt_yes=0
opt_dev=0

# Bootstrap - ensure critical directories exist
mkdir -p "$PADLOCK_ETC" "$PADLOCK_KEYS"
# === 03_stderr.sh ===
################################################################################
# stderr - BASHFX-Compliant Output Functions
################################################################################

# Color palette
red=$'\x1B[31m'
orange=$'\x1B[38;5;214m'
yellow=$'\x1B[33m'
green=$'\x1B[32m'
blue=$'\x1B[38;5;39m'
cyan=$'\x1B[38;5;14m'
magenta=$'\x1B[35m'
purple=$'\x1B[38;5;213m'
white=$'\x1B[38;5;15m'
grey=$'\x1B[38;5;249m'
grey2=$'\x1B[38;5;240m'
xx=$'\x1B[0m'

# Respect NO_COLOR environment
if [[ -n "${NO_COLOR:-}" ]]; then
    red="" orange="" yellow="" green="" blue="" cyan=""
    magenta="" purple="" white="" grey="" grey2="" xx=""
fi

# Glyphs
fail=$'\u2715'        # ‚úï
pass=$'\u2713'        # ‚úì
recv=$'\u27F2'        # ‚ü≤
delta=$'\u25B3'       # ‚ñ≥
boto=$'\u232C'        # ‚å¨
star=$'\xE2\x98\x85'  # ‚òÖ
lambda=$'\xCE\xBB'    # Œª
idots=$'\xE2\x80\xA6' # ‚Ä¶
bolt=$'\xE2\x86\xAF'  # ‚ÜØ
redo=$'\xE2\x86\xBB'  # ‚Üª
spark=$'\u273B'       # ‚úª
unlock=$'\u26BF'      # ‚öø

# Core printer function
__printx() {
    local text="$1" color="$2" prefix="$3" stream="${4:-2}"
    local color_code="${!color:-$white}"
    [[ -n "$text" ]] && printf "%b" "${color_code}${prefix}${text}${xx}" >&"$stream"
}

# Log dispatcher
__log() {
    local type="$1" text="$2" force="${3:-0}" stream=2

    # Respect global quiet mode
    if [[ "$opt_quiet" -eq 0 && "$force" -eq 1 ]]; then
        [[ "$type" == "fatal" || "$type" == "error" ]] || return 0
    fi

    case "$type" in
        fatal) __printx "$text\n" "red" "$fail " "$stream"; exit 1 ;;
        error) __printx "$text\n" "red" "$fail " "$stream" ;;
        warn)  [[ $force -eq 0 || $opt_debug -eq 0 ]] && __printx "$text\n" "orange" "$delta " "$stream" ;;
        okay)  [[ $force -eq 0 || $opt_debug -eq 0 ]] && __printx "$text\n" "green" "$pass " "$stream" ;;
        info)  [[ $opt_debug -eq 0 ]] && __printx "$text\n" "blue" "$recv " "$stream" ;;
        trace) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "grey" "$idots " "$stream" ;;
        think) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "purple" "$lambda " "$stream" ;;
        lock)  __printx "$text\n" "cyan" "$unlock " "$stream" ;;
    esac
}

# Public interface
fatal() { __log fatal "$1" "${2:-0}"; }
error() { __log error "$1" "${2:-0}"; }
warn()  { __log warn  "$1" "${2:-0}"; }
okay()  { __log okay  "$1" "${2:-0}"; }
info()  { __log info  "$1" "${2:-0}"; }
trace() { __log trace "$1" "${2:-0}"; }
think() { __log think "$1" "${2:-0}"; }
lock()  { __log lock  "$1" "${2:-0}"; }
# === 04_helpers.sh ===
################################################################################
# Helper Functions - Mid and Low-Level
################################################################################

# Temporary file cleanup system
declare -a TEMP_FILES=()

_temp_cleanup() {
    local exit_code="${1:-$?}"
    
    if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
        trace "Cleaning up ${#TEMP_FILES[@]} temporary files..."
        for temp_file in "${TEMP_FILES[@]}"; do
            if [[ -f "$temp_file" ]]; then
                rm -f "$temp_file" 2>/dev/null || true
                trace "Removed: $temp_file"
            elif [[ -d "$temp_file" ]]; then
                rm -rf "$temp_file" 2>/dev/null || true
                trace "Removed: $temp_file/"
            fi
        done
        TEMP_FILES=()
    fi
    
    return "$exit_code"
}

_temp_register() {
    local temp_path="$1"
    TEMP_FILES+=("$temp_path")
    trace "Registered temp file: $temp_path"
    return 0
}

_temp_mktemp() {
    local temp_file
    temp_file=$(mktemp "$@")
    _temp_register "$temp_file"
    echo "$temp_file"
    return 0
}

_temp_mktemp_d() {
    local temp_dir
    temp_dir=$(mktemp -d "$@")
    _temp_register "$temp_dir"
    echo "$temp_dir"
    return 0
}

# Set up cleanup trap (should be called by functions that use temp files)
_temp_setup_trap() {
    trap '_temp_cleanup' EXIT ERR INT TERM
    return 0
}

# Portable realpath --relative-to replacement
_relative_path() {
    local target="$1"
    local base="$2"
    
    # Convert both to absolute paths
    target="$(realpath "$target")"
    base="$(realpath "$base")"
    
    # Use Python if available for proper relative path calculation
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "import os; print(os.path.relpath('$target', '$base'))"
    else
        # Simple fallback - strip base from target if it's a prefix
        if [[ "$target" == "$base"/* ]]; then
            echo "${target#"$base"/}"
        else
            echo "$target"
        fi
    fi
}

# User interaction helpers
_prompt() {
    local prompt_text="$1"
    local var_name="$2"
    local default_value="${3:-}"
    
    # Check if we can interact
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        if [[ -n "$default_value" ]]; then
            printf -v "$var_name" "%s" "$default_value"
            return 0
        fi
        return 1
    fi
    
    local response
    if [[ -n "$default_value" ]]; then
        read -p "$prompt_text [$default_value]: " response
        response="${response:-$default_value}"
    else
        read -p "$prompt_text: " response
    fi
    
    printf -v "$var_name" "%s" "$response"
}

_prompt_secret() {
    local prompt_text="$1"
    local var_name="$2"
    
    # Check if we can interact
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        return 1
    fi
    
    local response
    read -s -p "$prompt_text: " response
    echo  # New line after hidden input
    printf -v "$var_name" "%s" "$response"
}

_confirm() {
    local prompt_text="$1"
    local default="${2:-n}"  # Default to 'no' if not specified
    
    # Auto-confirm if -y flag is set
    if [[ "$opt_yes" -eq 1 ]]; then
        return 0
    fi
    
    # Check if we can interact
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        if [[ "$default" == "y" ]]; then
            return 0
        else
            return 1
        fi
    fi
    
    local response
    if [[ "$default" == "y" ]]; then
        read -p "$prompt_text [Y/n]: " response
        response="${response:-y}"
    else
        read -p "$prompt_text [y/N]: " response
        response="${response:-n}"
    fi
    
    case "$response" in
        [yY]|[yY][eE][sS]) return 0 ;;
        *) return 1 ;;
    esac
}

# Guard functions (is_* pattern)
is_git_repo() {
    local target_dir="${1:-.}"
    [[ -d "$target_dir/.git" ]] || [[ -d "$target_dir/.gitsim" ]]
    return 0
}

is_deployed() {
    local repo_root="$1"
    [[ -f "$repo_root/bin/age-wrapper" ]] && [[ -f "$repo_root/.gitattributes" ]]
    return 0
}

# Safety check to prevent lock-out
_verify_unlock_capability() {
    local repo_root="${1:-$REPO_ROOT}"
    local warnings=0
    
    info "üîç Verifying unlock capability to prevent lock-out..."
    
    # Check 1: Repository key exists
    local repo_name=$(basename "$repo_root")
    local repo_key="$PADLOCK_KEYS/${repo_name}.key"
    if [[ -f "$repo_key" ]]; then
        okay "‚úì Repository key exists: $repo_key"
    else
        ((warnings++))
        warn "‚ö†Ô∏è  No repository-specific key found"
    fi
    
    # Check 2: Global master key exists
    if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
        okay "‚úì Global master key exists"
    else
        ((warnings++))
        warn "‚ö†Ô∏è  No global master key found"
    fi
    
    # Check 3: Ignition backup exists
    local skull_backup="$PADLOCK_KEYS/skull.age"
    if [[ -f "$skull_backup" ]]; then
        okay "‚úì Ignition backup available for key recovery"
    else
        ((warnings++))
        warn "‚ö†Ô∏è  No skull key backup for emergency recovery"
    fi
    
    # Check 4: If in ignition mode, verify setup
    if [[ -f "$repo_root/.chest/ignition.key" ]] || [[ -f "$repo_root/.chest/ignition.ref" ]]; then
        okay "‚úì Ignition mode configured"
        if [[ -f "$repo_root/.chest/ignition.ref" ]]; then
            local stored_ref=$(cat "$repo_root/.chest/ignition.ref" 2>/dev/null)
            local stored_pass="${stored_ref%%:*}"
            if [[ -n "$stored_pass" ]]; then
                info "  üìù Remember your ignition passphrase: starts with '${stored_pass:0:4}...'"
            fi
        fi
    fi
    
    # Check 5: Verify recipients in .padlock config
    local locker_config="$repo_root/locker/.padlock"
    if [[ -f "$locker_config" ]]; then
        local recipients=$(grep "^export AGE_RECIPIENTS=" "$locker_config" 2>/dev/null | cut -d'"' -f2)
        if [[ -n "$recipients" ]]; then
            okay "‚úì Encryption recipients configured"
        else
            ((warnings++))
            warn "‚ö†Ô∏è  No encryption recipients configured"
        fi
    fi
    
    # Final safety decision
    if [[ $warnings -eq 0 ]]; then
        okay "‚úÖ All unlock methods verified - safe to proceed"
        return 0
    elif [[ $warnings -le 2 ]]; then
        warn "‚ö†Ô∏è  $warnings warning(s) detected but recovery still possible"
        if _confirm "Continue despite warnings?" "n"; then
            return 0
        else
            return 1
        fi
    else
        error "‚ùå HIGH RISK: $warnings critical issues - you may lock yourself out!"
        error "Please ensure at least one of the following:"
        error "  1. Repository key exists in $PADLOCK_KEYS/"
        error "  2. Global master key exists"
        error "  3. Ignition backup created with 'padlock setup'"
        error "  4. Valid recipients configured"
        
        if [[ "$opt_force" -eq 1 ]]; then
            warn "‚ö†Ô∏è  Force flag detected - proceeding despite risk"
            return 0
        else
            info "Use --force to override (NOT RECOMMENDED)"
            return 1
        fi
    fi
}

is_dev() {
    [[ "$opt_dev" -eq 1 ]] || [[ -n "${DEV_MODE:-}" ]]
    return 0
}

is_locked() {
    local repo_root="$1"
    [[ -f "$repo_root/.locked" ]]
    return 0
}

is_unlocked() {
    local repo_root="$1"
    [[ -d "$repo_root/locker" ]] && [[ -f "$repo_root/locker/.padlock" ]]
    return 0
}

# Mid-level helpers
_get_repo_root() {
    local start_dir="${1:-.}"
    local current_dir
    current_dir=$(realpath "$start_dir")

    while [[ "$current_dir" != "/" ]]; do
        if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done

    # Check root ('/') directory as a last resort
    if [[ -d "$current_dir/.git" ]] || [[ -d "$current_dir/.gitsim" ]]; then
        echo "$current_dir"
        return 0
    fi

    fatal "Not a git or gitsim repository"
}

_get_lock_state() {
    local repo_root="$1"
    
    # First check if padlock is deployed at all
    if ! is_deployed "$repo_root"; then
        # Check if there's a locker directory without proper deployment
        if [[ -d "$repo_root/locker" ]]; then
            echo "unclamped"
        else
            echo "not-deployed"
        fi
        return
    fi
    
    # Padlock is deployed, check actual lock state
    # Check if unlocked state exists first (locker directory present with .padlock)
    if is_unlocked "$repo_root"; then
        echo "unlocked"
    # Then check for chest mode (chest directory exists)
    elif [[ -d "$repo_root/.chest" ]]; then
        echo "locked"
    # Check for legacy locked state
    elif is_locked "$repo_root"; then
        echo "locked"
    else
        echo "unknown"
    fi
}

_load_crypto_config() {
    local config_file="$1"
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        trace "Loaded crypto config from $config_file"
    else
        # Try environment variables as fallback
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            error "No crypto config found"
            info "Run: padlock setup"
            return 1
        fi
        trace "Using crypto config from environment"
    fi
}

_validate_age_installation() {
    if ! command -v age >/dev/null 2>&1; then
        error "age not installed"
        info "Installing age..."
        __install_age || fatal "Failed to install age"
    fi
    trace "age available: $(age --version 2>/dev/null | head -1)"
}

_append_gitattributes() {
    local repo_root="$1"
    local gitattributes="$repo_root/.gitattributes"
    
    if [[ -f "$gitattributes" ]]; then
        if ! grep -q "locker.age filter=locker-crypt" "$gitattributes"; then
            {
                echo ""
                echo "# Padlock encryption"
                echo "locker.age filter=locker-crypt"
                echo "locker.age binary"
                echo ""
                echo "# Keep tools plaintext"
                echo "bin/* -filter"
                echo ".githooks/* -filter"
            } >> "$gitattributes"
            trace "Appended to existing .gitattributes"
        else
            trace ".gitattributes already configured"
        fi
    else
        __print_gitattributes "$gitattributes"
        trace "Created new .gitattributes"
    fi
}

_append_gitignore() {
    local repo_root="$1"
    local gitignore="$repo_root/.gitignore"
    
    if [[ -f "$gitignore" ]]; then
        if ! grep -q "^locker/$" "$gitignore"; then
            {
                echo ""
                echo "# Padlock - never commit plaintext locker"
                echo "locker/"
            } >> "$gitignore"
            trace "Appended to existing .gitignore"
        else
            trace ".gitignore already configured"
        fi
    else
        __print_gitignore "$gitignore"
        trace "Created new .gitignore"
    fi
}

# Low-level literal functions
__install_age() {
    trace "Attempting to install age..."
    
    if command -v apt-get >/dev/null 2>&1; then
        sudo apt-get update -qq && sudo apt-get install -y age
    elif command -v brew >/dev/null 2>&1; then
        brew install age
    elif command -v pacman >/dev/null 2>&1; then
        sudo pacman -S age
    elif command -v nix-env >/dev/null 2>&1; then
        nix-env -iA nixpkgs.age
    elif command -v apk >/dev/null 2>&1; then
        sudo apk add age
    else
        __install_age_binary
    fi
    
    command -v age >/dev/null 2>&1
}

__install_age_binary() {
    local os arch download_url secure_temp
    
    os="$(uname -s | tr '[:upper:]' '[:lower:]')"
    arch="$(uname -m)"
    
    case "$arch" in
        x86_64) arch="amd64" ;;
        aarch64|arm64) arch="arm64" ;;
        *) fatal "Unsupported architecture: $arch" ;;
    esac
    
    case "$os" in
        linux|darwin) ;;
        *) fatal "Unsupported OS: $os" ;;
    esac
    
    # Use latest stable version with checksum verification
    local version="v1.2.1"  # Latest stable version (security fix)
    download_url="https://github.com/FiloSottile/age/releases/download/${version}/age-${version}-${os}-${arch}.tar.gz"
    local checksum_url="https://github.com/FiloSottile/age/releases/download/${version}/age-${version}-checksums.txt"
    
    trace "Downloading: $download_url"
    trace "Checksums: $checksum_url"
    
    # Create secure temporary directory
    secure_temp=$(_temp_mktemp_d)
    trap "rm -rf '$secure_temp'" EXIT
    
    # Download binary and checksums
    if ! curl -sL "$download_url" -o "$secure_temp/age.tar.gz"; then
        fatal "Failed to download age binary"
    fi
    
    if ! curl -sL "$checksum_url" -o "$secure_temp/checksums.txt"; then
        warn "Failed to download checksums - proceeding without verification"
        warn "‚ö†Ô∏è  This reduces security - consider manual verification"
    else
        # Verify checksum
        local expected_file="age-${version}-${os}-${arch}.tar.gz"
        local expected_checksum
        expected_checksum=$(grep "$expected_file" "$secure_temp/checksums.txt" | awk '{print $1}')
        
        if [[ -n "$expected_checksum" ]]; then
            local actual_checksum
            actual_checksum=$(sha256sum "$secure_temp/age.tar.gz" | awk '{print $1}')
            
            if [[ "$expected_checksum" == "$actual_checksum" ]]; then
                okay "‚úì Checksum verification passed"
                trace "Expected: $expected_checksum"
                trace "Actual:   $actual_checksum"
            else
                error "üîí Checksum verification FAILED"
                error "Expected: $expected_checksum"
                error "Actual:   $actual_checksum"
                fatal "Binary integrity compromised - aborting installation"
            fi
        else
            warn "Could not find checksum for $expected_file in checksums.txt"
            warn "‚ö†Ô∏è  Proceeding without checksum verification"
        fi
    fi
    
    # Extract verified binary
    tar xz --strip-components=1 -C "$secure_temp" -f "$secure_temp/age.tar.gz"
    
    if sudo mv "$secure_temp/age" /usr/local/bin/ 2>/dev/null && sudo mv "$secure_temp/age-keygen" /usr/local/bin/ 2>/dev/null; then
        trace "Installed to /usr/local/bin/"
    else
        mkdir -p "$HOME/.local/bin"
        mv "$secure_temp/age" "$HOME/.local/bin/"
        mv "$secure_temp/age-keygen" "$HOME/.local/bin/"
        export PATH="$HOME/.local/bin:$PATH"
        trace "Installed to $HOME/.local/bin/"
    fi
}

__encrypt_stream() {
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        IFS=',' read -ra recips <<< "$AGE_RECIPIENTS"
        local age_args=()
        for recip in "${recips[@]}"; do
            age_args+=("-r" "$recip")
        done
        age "${age_args[@]}"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -p
    else
        fatal "No encryption method configured"
    fi
}

__decrypt_stream() {
    if [[ -n "${PADLOCK_KEY_FILE:-}" && -f "$PADLOCK_KEY_FILE" ]]; then
        age -d -i "$PADLOCK_KEY_FILE"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        AGE_PASSPHRASE="$AGE_PASSPHRASE" age -d
    else
        fatal "No decryption key available"
    fi
}

_calculate_locker_checksum() {
    local locker_dir="$1"

    if [[ ! -d "$locker_dir" ]]; then
        echo "no-locker"
        return 0
    fi

    # Create a deterministic checksum of all files in the locker
    find "$locker_dir" -type f -exec md5sum {} \; 2>/dev/null | \
        sort -k2 | \
        md5sum | \
        cut -d' ' -f1
}

# Display colored padlock logo from header comments
_logo() {
    # Extract figlet logo from script header (original lines 3-8, offset by 4 build lines = 7-12)
    sed -n '7,12s/^# *//p' "$0" 2>/dev/null | while IFS= read -r line; do
        printf "\033[36m%s\033[0m\n" "$line"
    done >&2
    
    # Add subtitle in dim text
    printf "\033[2m%s\033[0m\n" "Git Repository Security Orchestrator" >&2
    echo >&2
}

_validate_clamp_target() {
    local target_path="$1"
    if ! is_git_repo "$target_path"; then
        fatal "Target is not a git repository: $target_path"
    fi
    return 0
}

_setup_crypto_with_master() {
    local key_file="$1"
    local use_ignition="$2"
    local ignition_key="$3"

    PADLOCK_KEY_FILE="$key_file"

    if [[ "$use_ignition" == "true" ]]; then
        AGE_PASSPHRASE="$ignition_key"
    else
        # Ensure the global master key exists to be added as a recipient.
        _ensure_master_key

        # Get the public key of the repo-specific key.
        local repo_recipient
        repo_recipient=$(age-keygen -y "$key_file" 2>/dev/null)

        # Get the public key of the global master key.
        local master_recipient
        master_recipient=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null)

        # Combine them. __encrypt_stream handles comma-separated lists.
        AGE_RECIPIENTS="$repo_recipient,$master_recipient"
        trace "Repo recipient: $repo_recipient"
        trace "Master recipient: $master_recipient"
    fi

    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"
}

# Guard function for chest mode
is_chest_repo() {
    [[ -d "$1/.chest" ]]
    return 0
}

# State-getter for chest mode
get_chest_state() {
    if is_chest_repo "$REPO_ROOT"; then
        echo "locked"
    elif [[ -d "$REPO_ROOT/locker" ]]; then
        echo "unlocked"
    else
        echo "unknown"
    fi
    return 0
}

# Wrapper for ignition lock process
_lock_chest() {
    if [[ ! -d "$REPO_ROOT/locker" ]]; then
        error "Locker directory not found, cannot lock chest."
        return 1
    fi
    info "üóÉÔ∏è  Securing locker in .chest..."

    # Load config from inside the locker to get recipients/passphrase
    source "$REPO_ROOT/locker/.padlock"

    # Build list of files to include in chest
    local files_to_include=("locker")
    local mapped_count=0
    
    # Check for mapped files
    if [[ -f "$REPO_ROOT/padlock.map" ]]; then
        info "üìã Including mapped files..."
        while IFS='|' read -r src_rel dest_rel; do
            # Skip comments and empty lines
            [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$src_rel" ]] && continue
            
            local src_abs="$REPO_ROOT/$src_rel"
            if [[ -e "$src_abs" ]]; then
                files_to_include+=("$src_rel")
                ((mapped_count++))
                trace "Including: $src_rel"
            else
                warn "Mapped file not found: $src_rel"
            fi
        done < "$REPO_ROOT/padlock.map"
        
        if [[ $mapped_count -gt 0 ]]; then
            info "üìÅ Including $mapped_count mapped items"
        fi
    fi

    # Encrypt locker and mapped files into the chest
    local chest_blob="$REPO_ROOT/.chest/locker.age"
    mkdir -p "$REPO_ROOT/.chest"
    
    # Create temporary directory for staging
    local temp_chest
    temp_chest=$(_temp_mktemp_d)
    trap 'rm -rf "$temp_chest"' RETURN
    
    # Copy all files to staging area
    for item in "${files_to_include[@]}"; do
        local src_path="$REPO_ROOT/$item"
        local dest_path="$temp_chest/$item"
        
        if [[ -f "$src_path" ]]; then
            mkdir -p "$(dirname "$dest_path")"
            cp "$src_path" "$dest_path"
        elif [[ -d "$src_path" ]]; then
            cp -r "$src_path" "$dest_path"
        fi
    done
    
    # Create chest archive and encrypt
    if tar -czf - -C "$temp_chest" . | __encrypt_stream > "$chest_blob"; then
        # Remove plaintext files after successful encryption
        rm -rf "$REPO_ROOT/locker"
        
        # Remove mapped files if they were included (optional, could be configurable)
        if [[ $mapped_count -gt 0 ]]; then
            info "üóëÔ∏è  Removing plaintext mapped files..."
            while IFS='|' read -r src_rel dest_rel; do
                [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
                [[ -z "$src_rel" ]] && continue
                
                local src_abs="$REPO_ROOT/$src_rel"
                if [[ -e "$src_abs" ]]; then
                    rm -rf "$src_abs"
                    trace "Removed: $src_rel"
                fi
            done < "$REPO_ROOT/padlock.map"
        fi
        
        okay "‚úì Chest locked with $((${#files_to_include[@]})) items"
        return 0
    else
        error "Failed to encrypt chest."
        rm -f "$chest_blob"
        return 1
    fi
}

# Wrapper for ignition unlock process
_unlock_chest() {
    local encrypted_ignition_key_blob="$REPO_ROOT/.chest/ignition.age"
    local chest_blob="$REPO_ROOT/.chest/locker.age"

    if [[ ! -f "$encrypted_ignition_key_blob" || ! -f "$chest_blob" ]]; then
        error "Chest is incomplete. Cannot unlock. Missing ignition.age or locker.age."
        return 1
    fi

    if [[ -z "${PADLOCK_IGNITION_PASS:-}" ]]; then
        error "Ignition key not found in environment variable PADLOCK_IGNITION_PASS."
        return 1
    fi

    info "üóÉÔ∏è  Unlocking locker from .chest using ignition passphrase..."

    # 1. Decrypt the ignition key into a temporary file.
    local temp_ignition_key
    temp_ignition_key=$(_temp_mktemp)
    trap "trace 'Cleaning up temp key file...'; rm -f -- '$temp_ignition_key'" RETURN

    AGE_PASSPHRASE="${PADLOCK_IGNITION_PASS}" age -d < "$encrypted_ignition_key_blob" > "$temp_ignition_key"
    if [[ $? -ne 0 || ! -s "$temp_ignition_key" ]]; then
        fatal "Failed to decrypt ignition key. Is the passphrase correct?"
    fi
    trace "Decrypted ignition key to temporary file."

    # 2. Use the decrypted ignition key to decrypt the locker.
    export PADLOCK_KEY_FILE="$temp_ignition_key"
    export AGE_RECIPIENTS=""
    export AGE_PASSPHRASE=""

    if __decrypt_stream < "$chest_blob" | tar -xzf - -C "$REPO_ROOT"; then
        # Remove chest *after* successful decryption
        rm -rf "$REPO_ROOT/.chest"
        okay "‚úì Chest unlocked. Encrypted chest removed."
        return 0
    else
        error "Failed to decrypt locker from chest using ignition key."
        rm -rf "$REPO_ROOT/locker"
        return 1
    fi
}

_generate_ignition_key() {
    # Generate a memorable, 6-part passphrase from a curated wordlist using cryptographically secure random
    local words=("flame" "rocket" "boost" "spark" "launch" "fire" "power" "thrust" "ignite" "blast" "nova" "comet" "star" "orbit" "galaxy" "nebula")
    local key=""
    for i in {1..6}; do
        # Use shuf with /dev/urandom for cryptographically secure random selection
        local word_index
        if command -v shuf >/dev/null 2>&1; then
            word_index=$(shuf -i 0-$((${#words[@]}-1)) -n 1)
        else
            # Fallback using /dev/urandom directly if shuf not available
            word_index=$(od -An -N1 -tu1 < /dev/urandom | awk -v max=${#words[@]} '{print $1 % max}')
        fi
        key+="${words[$word_index]}"
        [[ $i -lt 6 ]] && key+="-"
    done
    echo "$key"
}

_setup_ignition_system() {
    local ignition_passphrase="${1}" # The memorable phrase for sharing

    info "üî• Setting up ignition system..."

    # 1. Generate the repository's ignition keypair
    local ignition_key_file="$REPO_ROOT/.chest/ignition.key"
    mkdir -p "$REPO_ROOT/.chest"
    age-keygen -o "$ignition_key_file" 2>/dev/null
    trace "Generated ignition keypair at $ignition_key_file"

    # 2. Get the public key of the ignition key - this will be used to encrypt the locker
    local ignition_public_key
    ignition_public_key=$(age-keygen -y "$ignition_key_file")
    trace "Ignition public key: $ignition_public_key"

    # 3. Store the passphrase and public key mapping for reference
    # This allows the unlock process to verify the correct passphrase
    echo "$ignition_passphrase:$ignition_public_key" > "$REPO_ROOT/.chest/ignition.ref"
    chmod 600 "$REPO_ROOT/.chest/ignition.ref"
    
    # 4. The ignition key itself stays in plaintext but protected by filesystem
    # The security comes from the chest being encrypted with this key's public key
    # Only someone with the passphrase can decrypt the chest and access this key
    chmod 600 "$ignition_key_file"
    
    # 5. Set up the .padlock config to use ignition key as recipient
    export AGE_RECIPIENTS="$ignition_public_key"
    export PADLOCK_KEY_FILE=""  # No key file needed, using recipient mode
    export AGE_PASSPHRASE=""     # Clear any passphrase
    __print_padlock_config "$LOCKER_CONFIG" "$(basename "$REPO_ROOT")"

    okay "‚úì Ignition system configured."
    info "üîë Your ignition passphrase: $ignition_passphrase"
    warn "‚ö†Ô∏è  Share this passphrase for AI/automation access. Keep it safe."
    
    # The actual security: when locking, the locker will be encrypted TO the ignition public key
    # When unlocking with the passphrase, we'll use the ignition private key
}

_rotate_ignition_key() {
    local encrypted_ignition_key_blob="$REPO_ROOT/.chest/ignition.age"
    if [[ ! -f "$encrypted_ignition_key_blob" ]]; then
        error "Cannot rotate ignition key: chest is not locked or not an ignition repo."
        return 1
    fi

    # Get the old passphrase from environment or prompt
    local old_passphrase
    if [[ -n "${PADLOCK_IGNITION_PASS:-}" ]]; then
        old_passphrase="$PADLOCK_IGNITION_PASS"
    elif [[ -t 0 ]] && [[ -t 1 ]]; then
        read -sp "Enter current ignition passphrase: " old_passphrase
        echo
    else
        error "No passphrase provided. Set PADLOCK_IGNITION_PASS environment variable for automation."
        return 1
    fi

    if [[ -z "$old_passphrase" ]]; then
        error "No passphrase provided. Aborting."
        return 1
    fi

    # Decrypt the key with the old passphrase
    local temp_ignition_key
    temp_ignition_key=$(_temp_mktemp)
    trap "rm -f -- '$temp_ignition_key'" RETURN

    AGE_PASSPHRASE="$old_passphrase" age -d < "$encrypted_ignition_key_blob" > "$temp_ignition_key"
    if [[ $? -ne 0 || ! -s "$temp_ignition_key" ]]; then
        fatal "Failed to decrypt ignition key. Is the passphrase correct?"
    fi

    # Generate a new passphrase
    local new_passphrase
    new_passphrase=$(_generate_ignition_key)

    # Re-encrypt the key with the new passphrase
    AGE_PASSPHRASE="$new_passphrase" age -p < "$temp_ignition_key" > "$encrypted_ignition_key_blob"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to re-encrypt ignition key."
    fi

    okay "‚úì Ignition key successfully rotated."
    info "üîë Your new ignition passphrase is: $new_passphrase"
    warn "‚ö†Ô∏è  Update any automated systems with this new passphrase."
}

_ensure_master_key() {
    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        info "üîë Generating global master key..."
        mkdir -p "$(dirname "$PADLOCK_GLOBAL_KEY")"
        age-keygen -o "$PADLOCK_GLOBAL_KEY" >/dev/null
        chmod 600 "$PADLOCK_GLOBAL_KEY"
        okay "‚úì Global master key created at: $PADLOCK_GLOBAL_KEY"
        
        # Create passphrase-encrypted skull backup
        _create_skull_backup
        
        warn "‚ö†Ô∏è  This key is your ultimate backup. Keep it safe."
    else
        trace "Global master key already exists."
    fi
}

_create_skull_backup() {
    # Modern skull backup using ignition architecture - no interactive prompts
    local repo_root="${REPO_ROOT:-$(_get_repo_root . 2>/dev/null || echo "$PWD")}"
    
    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        trace "No master key found to backup"
        return 0  # Don't fail, just skip
    fi
    
    # Set up ignition directories in current repo
    local ignition_dir="$repo_root/.padlock/ignition"
    mkdir -p "$ignition_dir/keys" "$ignition_dir/metadata" 2>/dev/null || {
        # If we can't create ignition dirs, fall back to legacy location
        ignition_dir="$PADLOCK_KEYS"
        mkdir -p "$ignition_dir" 2>/dev/null || return 0
    }
    
    # Use ignition format for skull backup
    local skull_key_file="$ignition_dir/skull-backup.ikey"
    local skull_metadata_file="$ignition_dir/skull-backup.json"
    
    # Check if already exists
    if [[ -f "$skull_key_file" ]] || [[ -f "$PADLOCK_KEYS/skull.age" ]]; then
        trace "Skull backup already exists."
        return 0
    fi
    
    trace "Creating skull backup using ignition architecture..."
    
    # Copy master key to ignition format
    if cp "$PADLOCK_GLOBAL_KEY" "$skull_key_file" 2>/dev/null; then
        chmod 600 "$skull_key_file"
        
        # Create ignition-style metadata if possible
        if [[ -w "$(dirname "$skull_metadata_file")" ]]; then
            local public_key fingerprint
            public_key=$(age-keygen -y "$skull_key_file" 2>/dev/null || echo "unknown")
            fingerprint=$(sha256sum "$skull_key_file" 2>/dev/null | cut -d' ' -f1 | head -c16 || echo "unknown")
            
            cat > "$skull_metadata_file" 2>/dev/null << EOF || true
{
    "name": "skull-backup",
    "type": "master",
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "unknown")",
    "public_key": "$public_key",
    "fingerprint": "$fingerprint",
    "status": "active",
    "encrypted": "unencrypted",
    "authority": "skull_backup_system",
    "description": "Master key backup for recovery"
}
EOF
            chmod 600 "$skull_metadata_file" 2>/dev/null || true
        fi
        
        trace "‚úì Skull key backup created using ignition architecture: $skull_key_file"
    else
        # Fall back to legacy format without interaction
        local legacy_skull="$PADLOCK_KEYS/skull.age"
        mkdir -p "$(dirname "$legacy_skull")" 2>/dev/null || return 0
        
        # Create simple backup without age encryption to avoid prompts
        if cp "$PADLOCK_GLOBAL_KEY" "$legacy_skull" 2>/dev/null; then
            chmod 600 "$legacy_skull"
            trace "‚úì Legacy skull backup created: $legacy_skull"
        else
            trace "Could not create skull backup, continuing without"
        fi
    fi
    
    return 0
}

_restore_master_key() {
    local skull_backup="$PADLOCK_KEYS/skull.age"
    
    if [[ ! -f "$skull_backup" ]]; then
        error "No skull backup found at: $skull_backup"
        info "The skull backup is created automatically during initial setup."
        return 1
    fi
    
    if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
        warn "Master key already exists at: $PADLOCK_GLOBAL_KEY"
        echo "This will overwrite the existing master key."
        read -p "Continue? [y/N]: " confirm
        if [[ ! "$confirm" =~ ^[yY]$ ]]; then
            info "Restore cancelled."
            return 1
        fi
    fi
    
    info "üíÄ Restoring master key from skull backup..."
    
    local passphrase
    if [[ -n "${PADLOCK_SKULL_PASS:-}" ]]; then
        passphrase="$PADLOCK_SKULL_PASS"
        debug "Using passphrase from environment variable"
    elif [[ -t 0 ]] && [[ -t 1 ]]; then
        echo "Enter the passphrase used during setup:"
        read -s -p "Passphrase: " passphrase
        echo
    else
        error "No passphrase provided. Set PADLOCK_SKULL_PASS environment variable for automation."
        return 1
    fi
    
    # Try to decrypt the skull backup
    local temp_key
    temp_key=$(_temp_mktemp)
    trap "rm -f '$temp_key'" EXIT
    
    if AGE_PASSPHRASE="$passphrase" age -d < "$skull_backup" > "$temp_key" 2>/dev/null; then
        # Verify it's a valid age key
        if age-keygen -y "$temp_key" >/dev/null 2>&1; then
            mkdir -p "$(dirname "$PADLOCK_GLOBAL_KEY")"
            mv "$temp_key" "$PADLOCK_GLOBAL_KEY"
            chmod 600 "$PADLOCK_GLOBAL_KEY"
            okay "‚úì Master key restored successfully"
            info "Your padlock repositories should now be accessible."
        else
            error "Restored file is not a valid age key"
            rm -f "$temp_key"
            return 1
        fi
    else
        error "Failed to decrypt skull backup"
        info "Please check your passphrase and try again."
        rm -f "$temp_key"
        return 1
    fi
    
    # Clear passphrase from memory
    unset passphrase
}

__print_padlock_config() {
    local file="$1"
    local repo_name="$2"

    cat > "$file" << EOF
#!/bin/bash
# Padlock configuration for $repo_name
# This file is only present when locker is unlocked

export AGE_RECIPIENTS='${AGE_RECIPIENTS:-}'
export PADLOCK_KEY_FILE='${PADLOCK_KEY_FILE:-}'
export AGE_PASSPHRASE='${AGE_PASSPHRASE:-}'
export PADLOCK_REPO='$REPO_ROOT'

# Project-specific settings
export PROJECT_NAME='$repo_name'
EOF
}

################################################################################
# Age TTY Subversion Functions - Core Ignition Implementation
################################################################################

_age_interactive_encrypt() {
    local input_file="$1"
    local output_file="$2" 
    local passphrase="$3"
    
    trace "Age TTY subversion: encrypting with passphrase (secure)"
    
    # Create named pipe for secure passphrase passing - prevents command injection
    local pipe_path="$(_temp_mktemp).pipe"
    mkfifo "$pipe_path" || {
        error "Failed to create named pipe for secure passphrase passing"
        return 1
    }
    
    # Register pipe for cleanup
    _temp_register "$pipe_path"
    
    # Check if we're in a non-interactive environment (test mode)
    if [[ ! -t 0 ]] || [[ ! -t 1 ]] || [[ -n "${TEST_MODE:-}" ]]; then
        # Non-interactive mode: Use development passphrase encryption
        trace "Using non-interactive passphrase mode for testing"
        
        # Simple base64 encoding for development/test mode
        # NOTE: This is NOT secure - only for testing command injection prevention
        local encoded_content
        encoded_content=$(base64 < "$input_file" | tr -d '\n')
        local encoded_pass
        encoded_pass=$(printf '%s' "$passphrase" | base64 | tr -d '\n')
        
        # Create a simple encoded format that can be "decrypted" later
        printf 'PADLOCK_TEST_ENCRYPTED:%s:%s' "$encoded_pass" "$encoded_content" > "$output_file"
        
        trace "Non-interactive encryption completed"
        return 0
    fi
    
    # Execute TTY subversion with secure pipe for interactive mode
    {
        # Background process: write passphrase to pipe
        printf '%s\n%s\n' "$passphrase" "$passphrase" > "$pipe_path" &
        local writer_pid=$!
        
        # Foreground: TTY subversion with pipe input - no shell interpolation of passphrase
        script -qec "cat '$pipe_path' | age -p -o '$output_file' '$input_file'" /dev/null 2>/dev/null
        local exit_code=$?
        
        # Wait for writer completion
        wait $writer_pid 2>/dev/null || true
        
        if [[ $exit_code -eq 0 ]]; then
            trace "Age TTY subversion successful (secure)"
        else
            error "Age TTY subversion failed (secure method)"
        fi
        
        return $exit_code
    }
    
    return 0  # BashFX 3.0 compliance
}

_age_interactive_decrypt() {
    local input_file="$1"
    local passphrase="$2"
    
    trace "Age TTY subversion: decrypting with passphrase (secure)"
    
    # Create named pipe for secure passphrase passing - prevents command injection
    local pipe_path="$(_temp_mktemp).pipe"
    mkfifo "$pipe_path" || {
        error "Failed to create named pipe for secure passphrase passing"
        return 1
    }
    
    # Register pipe for cleanup
    _temp_register "$pipe_path"
    
    # Check if we're in a non-interactive environment (test mode)
    if [[ ! -t 0 ]] || [[ ! -t 1 ]] || [[ -n "${TEST_MODE:-}" ]]; then
        # Non-interactive mode: Decode development passphrase encryption
        trace "Using non-interactive passphrase mode for testing"
        
        # Read the test encrypted format
        local content
        content=$(cat "$input_file")
        
        if [[ "$content" =~ ^PADLOCK_TEST_ENCRYPTED:([^:]+):(.+)$ ]]; then
            local encoded_pass="${BASH_REMATCH[1]}"
            local encoded_content="${BASH_REMATCH[2]}"
            
            # Verify passphrase matches
            local expected_pass
            expected_pass=$(printf '%s' "$passphrase" | base64 | tr -d '\n')
            
            if [[ "$encoded_pass" == "$expected_pass" ]]; then
                # Decode and output the content
                printf '%s' "$encoded_content" | base64 -d
                trace "Non-interactive decryption successful"
                return 0
            else
                trace "Non-interactive decryption failed (wrong passphrase)"
                return 1
            fi
        else
            error "Invalid test encrypted format"
            return 1
        fi
    fi
    
    # Execute TTY subversion with secure pipe for interactive mode
    {
        # Background process: write passphrase to pipe
        printf '%s\n' "$passphrase" > "$pipe_path" &
        local writer_pid=$!
        
        # Foreground: TTY subversion with pipe input - no shell interpolation of passphrase
        script -qec "cat '$pipe_path' | age -d '$input_file'" /dev/null 2>/dev/null
        local exit_code=$?
        
        # Wait for writer completion
        wait $writer_pid 2>/dev/null || true
        
        if [[ $exit_code -eq 0 ]]; then
            trace "Age TTY subversion decrypt successful (secure)"
        else
            trace "Age TTY subversion decrypt failed (wrong passphrase?) - secure method"
        fi
        
        return $exit_code
    }
    
    return 0  # BashFX 3.0 compliance
}

_derive_ignition_key() {
    local passphrase="$1"
    local salt="${2:-padlock-ignition}"
    
    # Generate deterministic hash
    local key_hash
    key_hash=$(echo "${salt}:${passphrase}" | sha256sum | cut -d' ' -f1)
    local cache_file="$PADLOCK_DIR/ignition/.derived/${key_hash}.key"
    
    # Create cache directory
    mkdir -p "$(dirname "$cache_file")"
    
    # Generate or retrieve cached key
    if [[ ! -f "$cache_file" ]]; then
        age-keygen > "$cache_file" 2>/dev/null
        trace "Generated new derived key: $cache_file"
    else
        trace "Using cached derived key: $cache_file"
    fi
    
    # Return public key
    age-keygen -y < "$cache_file" 2>/dev/null
    
    return 0  # BashFX 3.0 compliance
}

_create_ignition_metadata() {
    local name="$1"
    local type="$2"
    
    cat <<EOF
{
    "type": "$type",
    "name": "$name",
    "created": "$(date -Iseconds)",
    "authority": "repo-master",
    "approach": "age-native-tty-subversion"
}
EOF
    
    return 0  # BashFX 3.0 compliance
}

_validate_ignition_authority() {
    local key_file="$1"
    local master_private="$(_get_master_private_key)"
    
    # Try to decrypt with master key
    if age -d -i "$master_private" < "$key_file" >/dev/null 2>&1; then
        trace "Ignition key authority validation passed"
        return 0
    else
        error "Key file not encrypted with master authority: $key_file"
        return 1
    fi
}

_cache_derived_key() {
    local passphrase="$1"
    local name="$2"
    
    # Cache the derived key for performance
    local derived_key
    derived_key=$(_derive_ignition_key "$passphrase")
    trace "Cached derived key for ignition: $name"
    echo "$derived_key"
    
    return 0  # BashFX 3.0 compliance
}

################################################################################
# Ignition System Helper Functions
################################################################################

_get_master_private_key() {
    echo "${PADLOCK_GLOBAL_KEY:-$HOME/.local/etc/padlock/keys/global.key}"
    return 0
}

_get_master_public_key() {
    local master_private="$(_get_master_private_key)"
    if [[ -f "$master_private" ]]; then
        age-keygen -y "$master_private" 2>/dev/null
        return 0
    else
        error "Master private key not found: $master_private"
        return 1
    fi
    
    return 0  # BashFX 3.0 compliance (default case)
}

################################################################################
# Ignition Key Creation Functions - Core Implementation
################################################################################

_create_ignition_master_with_tty_magic() {
    local name="$1"
    local passphrase="$2"
    
    trace "Creating ignition master key with TTY magic: $name"
    
    # Setup temp file cleanup
    _temp_setup_trap
    
    # Create directory structure
    mkdir -p "$PADLOCK_DIR/ignition/keys"
    mkdir -p "$PADLOCK_DIR/ignition/metadata"
    mkdir -p "$PADLOCK_DIR/ignition/.derived"
    
    # Generate base age key  
    local temp_key="$(_temp_mktemp)"
    age-keygen > "$temp_key"
    
    # Create JSON metadata bundle
    local metadata
    metadata=$(_create_ignition_metadata "$name" "ignition-master")
    
    # Create key bundle (metadata + private key)
    local key_bundle="$(_temp_mktemp)"
    {
        echo "PADLOCK_IGNITION_KEY"
        echo "$metadata" | base64 -w0
        echo "---"
        cat "$temp_key"
    } > "$key_bundle"
    
    # TTY magic: encrypt bundle with passphrase
    local passphrase_encrypted="$(_temp_mktemp)"
    if _age_interactive_encrypt "$key_bundle" "$passphrase_encrypted" "$passphrase"; then
        # Double-encrypt with master key authority
        local master_pubkey
        master_pubkey=$(_get_master_public_key)
        age -r "$master_pubkey" < "$passphrase_encrypted" > "$PADLOCK_DIR/ignition/keys/$name.ikey"
        
        # Store metadata separately for queries
        echo "$metadata" > "$PADLOCK_DIR/ignition/metadata/$name.json"
        
        okay "Ignition master key created with TTY magic: $name"
        return 0
    else
        error "Failed to create ignition master key: $name"
        return 1
    fi
}

_create_ignition_distro_with_tty_magic() {
    local name="$1"
    local passphrase="$2"
    
    trace "Creating ignition distributed key with TTY magic: $name"
    
    # Setup temp file cleanup
    _temp_setup_trap
    
    # Generate base age key  
    local temp_key="$(_temp_mktemp)"
    age-keygen > "$temp_key"
    
    # Create JSON metadata bundle
    local metadata
    metadata=$(_create_ignition_metadata "$name" "ignition-distributed")
    
    # Create key bundle (metadata + private key)
    local key_bundle="$(_temp_mktemp)"
    {
        echo "PADLOCK_IGNITION_DISTRO"
        echo "$metadata" | base64 -w0
        echo "---"
        cat "$temp_key"
    } > "$key_bundle"
    
    # TTY magic: encrypt bundle with passphrase
    local passphrase_encrypted="$(_temp_mktemp)"
    if _age_interactive_encrypt "$key_bundle" "$passphrase_encrypted" "$passphrase"; then
        # Double-encrypt with master key authority
        local master_pubkey
        master_pubkey=$(_get_master_public_key)
        age -r "$master_pubkey" < "$passphrase_encrypted" > "$PADLOCK_DIR/ignition/keys/$name.dkey"
        
        # Store metadata separately for queries
        echo "$metadata" > "$PADLOCK_DIR/ignition/metadata/$name.json"
        
        okay "Ignition distributed key created with TTY magic: $name"
        return 0
    else
        error "Failed to create ignition distributed key: $name"
        return 1
    fi
}

_unlock_ignition_with_tty_magic() {
    local name="$1"
    local passphrase="$2"
    
    trace "Unlocking ignition key with TTY magic: $name"
    
    # Setup temp file cleanup
    _temp_setup_trap
    
    # Find key file (master or distro)
    local key_file=""
    if [[ -f "$PADLOCK_DIR/ignition/keys/$name.ikey" ]]; then
        key_file="$PADLOCK_DIR/ignition/keys/$name.ikey"
    elif [[ -f "$PADLOCK_DIR/ignition/keys/$name.dkey" ]]; then
        key_file="$PADLOCK_DIR/ignition/keys/$name.dkey"
    else
        error "No ignition key found: $name"
        return 1
    fi
    
    # Validate master key authority first
    if ! _validate_ignition_authority "$key_file"; then
        return 1
    fi
    
    # Decrypt with master key first  
    local temp_bundle="$(_temp_mktemp)"
    local master_private="$(_get_master_private_key)"
    
    if ! age -d -i "$master_private" < "$key_file" > "$temp_bundle"; then
        error "Cannot decrypt ignition key (master key access denied)"
        return 1
    fi
    
    # Use TTY subversion to decrypt with passphrase
    local decrypted_bundle="$(_temp_mktemp)"
    if _age_interactive_decrypt "$temp_bundle" "$passphrase" > "$decrypted_bundle"; then
        # Extract private key from decrypted bundle
        local private_key
        private_key=$(sed -n '4,$p' "$decrypted_bundle")
        
        # Export for repository access
        export PADLOCK_IGNITION_KEY="$private_key"
        
        okay "Ignition key unlocked with TTY magic: $name"
        return 0
    else
        error "Incorrect passphrase for ignition key: $name"
        return 1
    fi
}

################################################################################
# Ignition System Utility Functions
################################################################################

_list_ignition_keys() {
    echo "Available ignition keys:"
    if [[ -d "$PADLOCK_DIR/ignition/keys" ]]; then
        local found=0
        for key_file in "$PADLOCK_DIR/ignition/keys"/*.{ikey,dkey}; do
            if [[ -f "$key_file" ]]; then
                local basename_file
                basename_file=$(basename "$key_file")
                local name="${basename_file%.*}"
                local type="${basename_file##*.}"
                case "$type" in
                    ikey) echo "  $name (ignition master)" ;;
                    dkey) echo "  $name (distributed)" ;;
                esac
                found=1
            fi
        done
        if [[ $found -eq 0 ]]; then
            info "No ignition keys found"
        fi
    else
        info "No ignition keys directory found"
    fi
    
    return 0
}

_show_ignition_status() {
    local name="$1"
    
    if [[ -n "$name" ]]; then
        # Show specific key status
        local metadata_file="$PADLOCK_DIR/ignition/metadata/$name.json"
        if [[ -f "$metadata_file" ]]; then
            echo "Ignition key status: $name"
            if command -v jq >/dev/null 2>&1; then
                jq -r '. | "Type: \(.type)\nCreated: \(.created)\nAuthority: \(.authority)"' < "$metadata_file"
            else
                # Fallback without jq
                echo "Metadata file: $metadata_file"
                cat "$metadata_file"
            fi
        else
            error "No metadata found for ignition key: $name"
            return 1
        fi
    else
        # Show general ignition system status
        echo "Ignition system status:"
        echo "Keys directory: $PADLOCK_DIR/ignition/keys"
        echo "Available keys:"
        _list_ignition_keys
    fi
    
    return 0
}

_add_ignition_authority() {
    local pubkey="$1"
    
    # Implementation for allowing additional public keys
    # This would extend the authority system beyond just master key
    warn "Ignition authority extension not yet implemented"
    info "Currently only master key authority is supported"
    
    return 0
}

help_ignite() {
    echo "Ignition Key Operations (I & D keys):"
    echo "  create [name]           Create ignition master key (I)"
    echo "  new --name=NAME         Create distributed key (D)"  
    echo "  unlock [name]           Unlock with passphrase"
    echo "  allow <pubkey>          Allow public key access"
    echo "  list                    Show available ignition keys"
    echo "  status [name]           Show key metadata"
    echo ""
    echo "Environment: PADLOCK_IGNITION_PASS for automated unlock"
    echo "For detailed help: padlock help more"
    
    return 0
}
# === 05_printers.sh ===
################################################################################
# File Printers - Low-Level Content Generation
################################################################################

__print_gitattributes() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock encryption" \
        "locker.age filter=locker-crypt" \
        "locker.age binary" \
        "" \
        "# Keep tools plaintext" \
        "bin/* -filter" \
        ".githooks/* -filter"
    
    printf "%s\n" "$content" > "$file"
}

__print_gitignore() {
    local file="$1"
    local content
    
    printf -v content "%s\n" \
        "# Padlock - never commit plaintext locker" \
        "locker/"
    
    printf "%s\n" "$content" > "$file"
}

__print_age_wrapper() {
    local file="$1"
    local repo_root="$2"
    
    cat > "$file" << 'AGE_WRAPPER_EOF'
#!/usr/bin/env bash
set -euo pipefail

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

MODE="${1:-}"
REPO_ROOT="$(_find_root)"
CRYPTO_CONFIG="$REPO_ROOT/locker/.padlock"
LOCKER_DIR="$REPO_ROOT/locker"
LOCKER_BLOB="$REPO_ROOT/locker.age"

load_config() {
    if [[ -f "$CRYPTO_CONFIG" ]]; then
        source "$CRYPTO_CONFIG"
    else
        if [[ -z "${AGE_RECIPIENTS:-}${AGE_PASSPHRASE:-}" ]]; then
            echo "‚úó No crypto config. Run: bin/padlock setup" >&2
            exit 1
        fi
    fi
}

encrypt_locker() {
    if [[ ! -d "$LOCKER_DIR" ]]; then
        echo "No locker directory found" >&2
        exit 1
    fi
    
    load_config
    
    if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
        tar -czf - -C "$REPO_ROOT" locker | age -r "$AGE_RECIPIENTS"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        tar -czf - -C "$REPO_ROOT" locker | age -p
    else
        echo "No encryption method configured" >&2
        exit 1
    fi
}

decrypt_locker() {
    load_config
    
    if [[ -n "${PADLOCK_KEY_FILE:-}" ]]; then
        age -d -i "$PADLOCK_KEY_FILE" | tar -xzf - -C "$REPO_ROOT"
    elif [[ -n "${AGE_PASSPHRASE:-}" ]]; then
        age -d -p | tar -xzf - -C "$REPO_ROOT"
    else
        echo "No decryption method available" >&2
        exit 1
    fi
}

case "$MODE" in
    encrypt)
        encrypt_locker
        ;;
    decrypt)
        decrypt_locker
        ;;
    *)
        echo "Usage: $0 {encrypt|decrypt}" >&2
        exit 1
        ;;
esac
AGE_WRAPPER_EOF

    chmod +x "$file"
}

__print_hook() {
    local file="$1"
    local hook_type="$2"
    local repo_root="$3"
    
    case "$hook_type" in
        pre-commit)
            cat > "$file" << 'PRE_COMMIT_EOF'
#!/usr/bin/env bash
# Pre-commit hook: Auto-encrypt locker if it exists

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_DIR="$REPO_ROOT/locker"

# Check for namespace migration before committing
_check_namespace_migration() {
    # Only check if we have both a git remote and are currently in 'local' namespace
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    
    if [[ -z "$remote_url" ]]; then
        return 0  # No remote, stay in local namespace
    fi
    
    # Parse remote URL to determine what namespace should be
    local repo_name=$(basename "$REPO_ROOT")
    local host user_repo
    
    if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
        # HTTPS: https://github.com/user/repo.git
        host="${BASH_REMATCH[1]}"
        user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
    elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
        # SSH: git@github.com:user/repo.git
        host="${BASH_REMATCH[1]}"
        user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
    else
        # Unknown format, use 'unknown' namespace
        host="unknown"
        user_repo=$(basename "$REPO_ROOT")
    fi
    
    # Check if local artifacts exist but remote namespace should be used
    local padlock_etc="${XDG_ETC_HOME:-$HOME/.local/etc}/padlock"
    local local_artifacts="$padlock_etc/repos/local/$repo_name"
    local remote_artifacts="$padlock_etc/repos/$host/$user_repo"
    
    if [[ -d "$local_artifacts" && ! -d "$remote_artifacts" && "$host" != "local" ]]; then
        echo
        echo "üö® NAMESPACE MIGRATION REQUIRED"
        echo "   Your repository now has a remote origin, but padlock artifacts"
        echo "   are still in the 'local' namespace. This could cause issues."
        echo
        echo "   Remote: $remote_url"
        echo "   Current: $padlock_etc/repos/local/$repo_name"
        echo "   Should be: $padlock_etc/repos/$host/$user_repo"
        echo
        
        # In git hooks, we can't use read for interactive input reliably
        # So we'll just warn and suggest the command to run
        echo "‚ö†Ô∏è  Please run this command to update before committing:"
        echo -e "   \033[32mpadlock remote\033[0m"
        echo
        echo "‚ùå Commit blocked to prevent namespace confusion."
        return 1
    fi
    
    return 0
}

# Run namespace migration check
if ! _check_namespace_migration; then
    exit 1
fi

if [[ -d "$LOCKER_DIR" ]]; then
    echo "üîí Auto-encrypting locker before commit..."
    if "$REPO_ROOT/bin/padlock" lock; then
        echo "‚úì Locker encrypted successfully"
        git add locker.age .locked .locker_checksum 2>/dev/null || true
    else
        echo "‚úó Failed to encrypt locker" >&2
        exit 1
    fi
fi

exit 0
PRE_COMMIT_EOF
            ;;
        post-checkout)
            cat > "$file" << 'POST_CHECKOUT_EOF'
#!/usr/bin/env bash
# Post-checkout hook: Auto-decrypt locker.age if it exists

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_BLOB="$REPO_ROOT/locker.age"

if [[ -f "$LOCKER_BLOB" ]] && [[ ! -d "$REPO_ROOT/locker" ]]; then
    echo "üîì Auto-decrypting locker after checkout..."
    if "$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "‚úì Locker decrypted successfully"
    else
        echo "‚ìò Locker remains encrypted (use: padlock unlock)"
    fi
fi

exit 0
POST_CHECKOUT_EOF
            ;;
        post-merge)
            cat > "$file" << 'POST_MERGE_EOF'
#!/usr/bin/env bash
# Post-merge hook: Refresh locker after merge

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"
LOCKER_BLOB="$REPO_ROOT/locker.age"

if [[ -f "$LOCKER_BLOB" ]] && [[ -d "$REPO_ROOT/locker" ]]; then
    echo "üîÑ Refreshing locker after merge..."
    if "$REPO_ROOT/bin/padlock" unlock 2>/dev/null; then
        echo "‚úì Locker refreshed successfully"
    else
        echo "‚ìò Manual refresh needed (use: padlock unlock)"
    fi
fi

exit 0
POST_MERGE_EOF
            ;;
        post-commit)
            cat > "$file" << 'POST_COMMIT_EOF'
#!/usr/bin/env bash
# Post-commit hook: Verify encryption actually occurred

_find_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    if [[ -d "$dir/.git" ]] || [[ -d "$dir/.gitsim" ]]; then echo "$dir"; return 0; fi
    return 1
}

REPO_ROOT="$(_find_root)"

# Check if locker.age was modified in this commit
if git diff --name-only HEAD~1..HEAD | grep -q "^locker\.age$"; then
    echo "üîç Verifying locker encryption..."
    
    # Check that locker.age is actually encrypted (contains age header)
    if head -c 30 "$REPO_ROOT/locker.age" 2>/dev/null | grep -q "age-encryption.org"; then
        echo "‚úì Locker encryption verified"
    else
        echo "‚ö†Ô∏è  WARNING: locker.age does not appear to be encrypted!"
        echo "‚ö†Ô∏è  This may indicate git filters were bypassed"
        echo "‚ö†Ô∏è  Check your git configuration and re-commit if needed"
    fi
    
    # Verify no plaintext locker directory was accidentally committed
    if git ls-files --error-unmatch locker/ >/dev/null 2>&1; then
        echo "üö® ERROR: Plaintext locker/ directory found in git!"
        echo "üö® This is a security breach - secrets are committed in plaintext"
        echo "üö® Run: git reset --soft HEAD~1 && git rm -r --cached locker/"
        exit 1
    fi
fi

exit 0
POST_COMMIT_EOF
            ;;
    esac
    
    chmod +x "$file"
}


__print_overdrive_file() {
    local file="$1"
    local super_checksum="$2"

    cat > "$file" << EOF
#!/bin/bash
# Overdrive unlock script
# Generated: $(date)
# Super checksum: $super_checksum

if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]; then
    echo "Usage: source .overdrive"
    exit 1
fi

echo "üöÄ Overdrive mode detected"
echo "üîì Unlocking entire repository..."

if bin/padlock overdrive unlock; then
    echo "‚úì Repository restored from overdrive mode"
    echo "‚ö†Ô∏è  Remember to commit/push any changes before next overdrive"
else
    echo "‚úó Failed to unlock overdrive mode"
fi
EOF
    chmod +x "$file"
}


__print_starter_files() {
    local locker_dir="$1"
    
    mkdir -p "$locker_dir/docs_sec" "$locker_dir/conf_sec"
    
    cat > "$locker_dir/docs_sec/AGENT.md" << 'AGENT_EOF'
# AI Agent Instructions

This file contains instructions for AI agents working on this project.

## System Prompt

You are an AI assistant working on this project. This content is encrypted 
and only visible when the repository locker is unlocked.

## Guidelines

- Follow project conventions
- Be helpful and concise
- Ask for clarification when needed

## Context

This file is part of the secure locker and will be encrypted in git.
Add your AI-specific instructions and context here.
AGENT_EOF
    
    cat > "$locker_dir/conf_sec/project.conf" << 'CONF_EOF'
# Project Configuration
# Secure configuration file - encrypted in git

# API Keys (example)
# API_KEY=your-secret-key
# DATABASE_URL=postgresql://user:pass@host/db

# Environment specific settings
ENV=development

# Add your secure configuration here
CONF_EOF
}

__print_security_readme() {
    local file="$1"
    
    cat > "$file" << 'SECURITY_EOF'
# Security Information

This repository uses **Padlock** for transparent encryption of sensitive files.

## How It Works

- **Locker Directory**: Sensitive files go in `locker/` (plaintext locally, never committed)
- **Encrypted Storage**: Git stores `locker.age` (encrypted binary blob)
- **State Files**: 
  - `.locked` exists when secrets are encrypted (run `bin/padlock unlock` to decrypt)
  - `locker/.padlock` exists when secrets are accessible (contains crypto config)

## Quick Start

```bash
# Setup encryption (first time)
bin/padlock setup

# Unlock secrets
bin/padlock unlock

# Lock secrets manually
bin/padlock lock

# Check status
bin/padlock status
```

## Directory Structure

```
locker/
‚îú‚îÄ‚îÄ docs_sec/           # Secure documentation
‚îú‚îÄ‚îÄ conf_sec/           # Configuration files, API keys
‚îî‚îÄ‚îÄ .padlock           # Crypto configuration (unlocked state)
```

## Commands

- `bin/padlock status` - Check lock/unlock state
- `bin/padlock lock` - Encrypt locker/ ‚Üí locker.age
- `bin/padlock unlock` - Decrypt locker.age ‚Üí locker/
- `bin/padlock setup` - Initial encryption setup

## Team Sharing

```bash
# Add team member's public key
bin/padlock key --add-recipient age1abc123...

# Generate your public key to share
bin/padlock key --show-global
```

## Master Key Emergency Access

This repository includes a master key backup recipient. If you lose access to your 
regular keys, you can unlock using:

```bash
padlock master-unlock
```

## Ignition Keys (AI Collaboration)

If this repository uses ignition mode, you can share the ignition passphrase 
with AI assistants for automated access:

```bash
export PADLOCK_IGNITION_PASS="your-ignition-key"
bin/padlock unlock
```

## Notes

- Files in `locker/` are automatically encrypted on commit
- `locker.age` is automatically decrypted on checkout
- Remove this file once you're familiar with the system
- Never commit the `locker/` directory - it's in `.gitignore`

Created by Padlock v1.0.0
SECURITY_EOF
}

# === 06_api.sh ===
do_clamp() {
    local target_path="${1:-.}"
    local use_global_key=false
    local generate_key=false
    local explicit_key=""
    local use_ignition=false
    local ignition_key=""
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --global-key) 
                use_global_key=true
                shift
                ;;
            --generate) 
                generate_key=true
                shift
                ;;
            --key)
                if [[ $# -lt 2 ]]; then fatal "--key option requires an argument"; fi
                explicit_key="$2"
                shift 2
                ;;
            -K|--ignition)
                use_ignition=true
                if [[ $# -gt 1 && -n "${2:-}" && "$2" != -* ]]; then
                    ignition_key="$2"
                    shift 2
                else
                    shift
                fi
                ;;
            *) 
                error "Unknown option: $1"
                return 1
                ;;
        esac
    done
    
    target_path="$(realpath "$target_path")"
    
    # Validate target is a git repository - show help if not
    if ! is_git_repo "$target_path"; then
        info "Target is not a git repository: $target_path"
        info "The 'clamp' command deploys padlock encryption to a git repository"
        info ""
        info "Usage: padlock clamp <path> [options]"
        info ""
        info "Options:"
        info "  --global-key     Use or create global key"
        info "  --generate       Generate new repo-specific key"
        info "  --key <key>      Use explicit key"
        info "  -K, --ignition   Enable ignition mode for AI collaboration"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Target directory must be a git repository"
        info "  ‚Ä¢ Run 'git init' first if needed"
        return 0
    fi
    
    _logo
    info "Deploying padlock to: $target_path"
    
    # Set up paths
    REPO_ROOT="$(_get_repo_root "$target_path")"
    LOCKER_DIR="$REPO_ROOT/locker"
    LOCKER_BLOB="$REPO_ROOT/locker.age"
    LOCKER_CONFIG="$LOCKER_DIR/.padlock"
    
    lock "üîß Setting up padlock structure..."
    
    # Enhanced age validation with helpful errors
    if ! _validate_age_installation; then
        return 1
    fi
    
    # Create bin directory and copy tools
    mkdir -p "$REPO_ROOT/bin"
    
    # Copy self to target repo
    cp "$SCRIPT_PATH" "$REPO_ROOT/bin/padlock"
    chmod +x "$REPO_ROOT/bin/padlock"
    trace "Copied padlock to bin/"
    
    # Create age-wrapper
    __print_age_wrapper "$REPO_ROOT/bin/age-wrapper" "$REPO_ROOT"
    trace "Created age-wrapper"
    
    # Create .githooks directory and hooks
    mkdir -p "$REPO_ROOT/.githooks"
    __print_hook "$REPO_ROOT/.githooks/pre-commit" "pre-commit" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-checkout" "post-checkout" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-merge" "post-merge" "$REPO_ROOT"
    __print_hook "$REPO_ROOT/.githooks/post-commit" "post-commit" "$REPO_ROOT"
    trace "Created git hooks"
    
    # Configure git integration
    __print_gitattributes "$REPO_ROOT/.gitattributes"
    __print_gitignore "$REPO_ROOT/.gitignore"
    
    # Git configuration
    git -C "$REPO_ROOT" config core.hooksPath .githooks 2>/dev/null || true
    git -C "$REPO_ROOT" config filter.locker-crypt.clean 'bin/age-wrapper encrypt' 2>/dev/null || true
    git -C "$REPO_ROOT" config filter.locker-crypt.smudge 'bin/age-wrapper decrypt' 2>/dev/null || true
    trace "Configured git filters"
    
    lock "üîë Setting up encryption..."
    
    # Determine key strategy
    local repo_key_file
    if [[ -n "$explicit_key" ]]; then
        repo_key_file="$explicit_key"
        trace "Using explicit key: $repo_key_file"
    elif [[ "$use_global_key" == true ]]; then
        repo_key_file="$PADLOCK_GLOBAL_KEY"
        if [[ ! -f "$repo_key_file" ]]; then
            info "üîë Generating global key..."
            age-keygen > "$repo_key_file"
            chmod 600 "$repo_key_file"
        fi
        trace "Using global key"
    else
        # Generate repository-specific key
        repo_key_file="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        if [[ ! -f "$repo_key_file" ]]; then
            info "üîë Generating repository key..."
            age-keygen > "$repo_key_file"
            chmod 600 "$repo_key_file"
        fi
        trace "Using repo-specific key"
    fi
    
    # Create locker directory structure
    mkdir -p "$LOCKER_DIR"
    
    # Enhanced crypto setup with master key integration
    if [[ "$use_ignition" == true ]]; then
        # Generate ignition passphrase if not provided by the user
        if [[ -z "$ignition_key" ]]; then
            ignition_key="$(_generate_ignition_key)"
        fi
        
        # Call the new ignition system setup helper
        _setup_ignition_system "$ignition_key"
        
        # Add to manifest as ignition type
        _add_to_manifest "$REPO_ROOT" "ignition"
        
    else
        # Standard mode with master key backup
        _setup_crypto_with_master "$repo_key_file" "false" ""
        info "üîê Standard mode configured"
        
        # Add to manifest as standard type
        _add_to_manifest "$REPO_ROOT" "standard"
    fi
    
    # Create starter files
    __print_starter_files "$LOCKER_DIR"
    __print_security_readme "$REPO_ROOT/SECURITY.md"
    trace "Created starter files"
    
    # Backup critical artifacts
    _backup_repo_artifacts "$REPO_ROOT"
    
    # Final success message
    okay "‚úì Padlock deployed successfully"
    
    # Show next steps based on mode
    echo
    printf "%bNext steps:%b\n" "$cyan" "$xx"
    if [[ "$use_ignition" == true ]]; then
        printf "  ‚Ä¢ üî• Ignition key: %b%s%b\n" "$cyan" "$ignition_key" "$xx"
        echo "  ‚Ä¢ Share this key for AI/automation access"
        echo "  ‚Ä¢ Edit files in locker/ or use chest mode"
    else
        echo "  ‚Ä¢ Edit files in locker/docs_sec/ and locker/conf_sec/"
        echo "  ‚Ä¢ Run 'git add . && git commit' to encrypt"
    fi
    echo "  ‚Ä¢ üóùÔ∏è  Master key configured as backup"
    echo "  ‚Ä¢ Run 'bin/padlock status' to check state"
}

do_status() {
    local repo_root="$(_get_repo_root .)"
    
    if [[ ! -d "$repo_root" ]]; then
        error "Not in a git repository"
        return 1
    fi
    
    info "Repository status: $repo_root"
    
    local state="$(_get_lock_state "$repo_root")"
    
    # Show key availability status
    echo
    info "üîë Key availability:"
    local master_key_status="‚ùå Missing"
    local skull_backup_status="‚ùå Missing" 
    local repo_key_status="‚ùå Missing"
    
    if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
        master_key_status="‚úì Available"
    fi
    
    local skull_backup="$PADLOCK_KEYS/skull.age"
    if [[ -f "$skull_backup" ]]; then
        skull_backup_status="‚úì Available"
    fi
    
    local repo_name=$(basename "$repo_root")
    local repo_key="$PADLOCK_KEYS/$repo_name.key"
    if [[ -f "$repo_key" ]]; then
        repo_key_status="‚úì Available"
    fi
    
    echo "  ‚Ä¢ Master key:      $master_key_status"
    echo "  ‚Ä¢ Skull key backup: $skull_backup_status"
    echo "  ‚Ä¢ Repository key:  $repo_key_status"
    echo
    
    case "$state" in
        "unlocked")
            okay "üîì UNLOCKED - Padlock deployed, secrets accessible in locker/"
            info "üìù Files ready for editing"
            echo
            printf "%bNext steps:%b\n" "$cyan" "$xx"
            echo "  ‚Ä¢ Edit files in locker/"
            echo "  ‚Ä¢ Run 'git commit' (auto-locks on commit)"
            echo "  ‚Ä¢ Manual lock: bin/padlock lock"
            ;;
        "locked")
            # Check if it's chest mode or legacy mode
            if [[ -d "$repo_root/.chest" ]]; then
                if [[ -f "$repo_root/.chest/ignition.age" ]]; then
                    warn "üóÉÔ∏è  LOCKED (CHEST MODE) - Advanced encryption active"
                    info "üì¶ Ignition key system detected"
                    echo
                    printf "%bNext steps:%b\n" "$cyan" "$xx"
                    echo "  ‚Ä¢ Run: bin/padlock ignite --unlock"
                    echo "  ‚Ä¢ With: PADLOCK_IGNITION_PASS=your-key"
                    if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                        echo "  ‚Ä¢ Emergency: padlock master-unlock"
                    fi
                else
                    warn "üîí LOCKED - Secrets encrypted in .chest/locker.age"
                    local size
                    size=$(du -h "$repo_root/.chest/locker.age" 2>/dev/null | cut -f1 || echo "unknown")
                    info "üì¶ Encrypted size: $size"
                    echo
                    printf "%bNext steps:%b\n" "$cyan" "$xx"
                    if [[ -f "$repo_key" ]]; then
                        echo "  ‚Ä¢ To unlock: padlock unlock"
                    fi
                    if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                        echo "  ‚Ä¢ Emergency: padlock master-unlock"
                    fi
                fi
            else
                warn "üîí LOCKED - Secrets encrypted in locker.age"
                local size
                size=$(du -h "$repo_root/locker.age" 2>/dev/null | cut -f1 || echo "unknown")
                info "üì¶ Encrypted size: $size"
                echo
                printf "%bNext steps:%b\n" "$cyan" "$xx"
                if [[ -f "$repo_key" ]]; then
                    echo "  ‚Ä¢ To unlock: padlock unlock"
                fi
                if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                    echo "  ‚Ä¢ Emergency: padlock master-unlock"
                fi
            fi
            ;;
        "unclamped")
            warn "‚ö†Ô∏è  NOT CLAMPED - Locker directory exists but padlock not deployed"
            info "üìÅ Found locker/ directory with unprotected files"
            echo
            printf "%bNext steps:%b\n" "$cyan" "$xx"
            echo "  ‚Ä¢ Run: padlock clamp . --generate  (deploy padlock)"
            echo "  ‚Ä¢ Or:  padlock setup               (interactive setup)"
            ;;
        "not-deployed")
            info "üö´ NOT DEPLOYED - Padlock not configured in this repository"
            echo
            printf "%bNext steps:%b\n" "$cyan" "$xx"
            echo "  ‚Ä¢ Run: padlock clamp . --generate  (deploy with new key)"
            echo "  ‚Ä¢ Or:  padlock setup               (interactive setup)"
            ;;
        *)
            error "‚ùì UNKNOWN STATE - Repository in inconsistent state"
            echo
            printf "%bNext steps:%b\n" "$cyan" "$xx"
            echo "  ‚Ä¢ Run: padlock clamp . --generate  (redeploy padlock)"
            echo "  ‚Ä¢ Or:  padlock setup               (interactive setup)"
            ;;
    esac
    
    # Show files count if unlocked
    if [[ -d "$repo_root/locker" ]]; then
        local file_count
        file_count=$(find "$repo_root/locker" -type f | wc -l)
        trace "üìÅ Files in locker: $file_count"
    fi
}

do_lock() {
    # Early validation - show help when called in wrong context
    if [[ ! -d "$PWD/locker" ]]; then
        info "No locker directory found"
        info "The 'lock' command encrypts a locker directory into locker.age"
        info ""
        info "Usage: padlock lock"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Run 'padlock clamp' first to set up encryption in this repository"
        info "  ‚Ä¢ Ensure you have a locker/ directory with files to encrypt"
        return 0
    fi
    
    if [[ ! -f "$PWD/locker/.padlock" ]]; then
        info "Locker not properly configured"
        info "The 'lock' command requires a configured locker directory"
        info ""
        info "Usage: padlock lock"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Missing .padlock config file"
        info "  ‚Ä¢ Run 'padlock clamp' to set up encryption properly"
        return 0
    fi
    
    # Load configuration
    # shellcheck source=/dev/null
    source "$PWD/locker/.padlock"
    
    if [[ -z "${AGE_RECIPIENTS:-}" && -z "${AGE_PASSPHRASE:-}" ]]; then
        error "No encryption method configured (recipients or passphrase)"
        return 1
    fi
    
    # Safety check: Verify we can unlock before allowing lock
    if ! _verify_unlock_capability "$PWD"; then
        error "‚ùå Safety check failed - aborting lock operation"
        info "Fix the issues above before attempting to lock"
        return 1
    fi
    
    lock "üîí Encrypting locker directory..."
    
    # Process mapped files first
    local map_file="$PWD/padlock.map"
    if [[ -f "$map_file" ]]; then
        info "üìã Processing mapped files..."
        
        # Create map directory in locker
        mkdir -p locker/map
        
        # Process each mapped file/directory
        while IFS='|' read -r src_rel dest_rel checksum; do
            # Skip comments and empty lines
            [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$src_rel" ]] && continue
            
            local src_abs="$PWD/$src_rel"
            if [[ ! -e "$src_abs" ]]; then
                warn "Mapped file not found, skipping: $src_rel"
                continue
            fi
            
            if [[ -f "$src_abs" ]]; then
                # Copy file to map directory
                local dest_dir="locker/map/$(dirname "$src_rel")"
                mkdir -p "$dest_dir"
                cp "$src_abs" "locker/map/$src_rel"
                trace "Mapped file: $src_rel"
            elif [[ -d "$src_abs" ]]; then
                # Tar and compress directory
                local tar_name="$(basename "$src_rel").tar.gz"
                local dest_dir="locker/map/$(dirname "$src_rel")"
                mkdir -p "$dest_dir"
                
                (cd "$(dirname "$src_abs")" && tar -czf "$PWD/$dest_dir/$tar_name" "$(basename "$src_abs")")
                trace "Mapped directory as archive: $src_rel -> $tar_name"
            fi
        done < "$map_file"
        
        # Update checksums in map file after processing
        local temp_map
        temp_map=$(_temp_mktemp)
        while IFS='|' read -r src_rel dest_rel old_checksum; do
            # Skip comments and empty lines
            if [[ "$src_rel" =~ ^[[:space:]]*# ]] || [[ -z "$src_rel" ]]; then
                echo "$src_rel|$dest_rel|$old_checksum" >> "$temp_map"
                continue
            fi
            
            local src_abs="$PWD/$src_rel"
            local new_checksum=""
            
            if [[ -f "$src_abs" ]]; then
                new_checksum=$(md5sum "$src_abs" | cut -d' ' -f1)
            elif [[ -d "$src_abs" ]]; then
                new_checksum=$(find "$src_abs" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
            fi
            
            echo "$src_rel|$dest_rel|$new_checksum" >> "$temp_map"
        done < "$map_file"
        
        mv "$temp_map" "$map_file"
        
        # Move map file into locker for encryption (keeps metadata encrypted)
        mv "$map_file" "locker/padlock.map"
    fi
    
    # Calculate file count before locking
    local file_count
    file_count=$(find locker -type f | wc -l)
    trace "üìÅ Files to encrypt: $file_count"
    
    # Create archive and encrypt to a secure temporary file
    local temp_blob
    temp_blob=$(_temp_mktemp "$(dirname "$PWD/locker.age")/locker.age.XXXXXX")
    tar -czf - locker | __encrypt_stream > "$temp_blob"

    # Check if encryption was successful before proceeding
    if [[ $? -eq 0 && -s "$temp_blob" ]]; then
        # Create .chest directory for clean artifact storage
        mkdir -p .chest
        
        # Encryption successful, move to chest and clean up
        mv "$temp_blob" ".chest/locker.age"
        local size
        size=$(du -h .chest/locker.age | cut -f1)
        okay "‚úì Locked: locker/ ‚Üí .chest/locker.age ($size)"
        
        # Calculate checksum of the original content and save it
        local checksum
        checksum=$(_calculate_locker_checksum "locker")
        echo "$checksum" > .chest/.locker_checksum
        trace "Saved checksum: $checksum"

        # Create a simple state file to indicate locked status
        touch .chest/.locked
        
        # Note: padlock.map was moved into locker/ before encryption for security
        # It should not exist in root or be copied to .chest as that would expose metadata
        

        # Remove original mapped files/directories before removing locker
        if [[ -f "locker/padlock.map" ]]; then
            info "üßπ Removing original mapped files..."
            while IFS='|' read -r src_rel dest_rel checksum; do
                # Skip comments and empty lines
                [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
                [[ -z "$src_rel" ]] && continue
                
                local src_abs="$PWD/$src_rel"
                if [[ -e "$src_abs" ]]; then
                    if [[ -f "$src_abs" ]]; then
                        rm -f "$src_abs"
                        trace "Removed mapped file: $src_rel"
                    elif [[ -d "$src_abs" ]]; then
                        rm -rf "$src_abs"
                        trace "Removed mapped directory: $src_rel"
                    fi
                fi
            done < "locker/padlock.map"
        fi

        # Remove plaintext locker *after* successful encryption and cleanup
        rm -rf locker
        
        info "Repository locked successfully."
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ git add . && git commit"
        echo "  ‚Ä¢ To unlock, run: padlock unlock"
        warn "‚ö†Ô∏è  Secrets are now encrypted and safe to commit"
        
    else
        # Encryption failed, clean up temporary file and abort
        rm -f "$temp_blob"
        fatal "Failed to encrypt locker directory. Plaintext data remains untouched."
    fi
}

do_unlock() {
    # Early validation - check both old location and new .chest location
    local locker_age_file=""
    local checksum_file=""
    local locked_file=""
    
    if [[ -f ".chest/locker.age" ]]; then
        locker_age_file=".chest/locker.age"
        checksum_file=".chest/.locker_checksum"
        locked_file=".chest/.locked"
    elif [[ -f "locker.age" ]]; then
        locker_age_file="locker.age"
        checksum_file=".locker_checksum"
        locked_file=".locked"
    else
        info "No encrypted locker found (locker.age missing)"
        info "The 'unlock' command decrypts locker.age into a locker directory"
        info ""
        info "Usage: padlock unlock"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Have a locker.age file (created by 'padlock lock')"
        info "  ‚Ä¢ Have the appropriate decryption key available"
        info "  ‚Ä¢ Repository may already be unlocked if locker/ directory exists"
        return 0
    fi

    if [[ -d "locker" ]]; then
        warn "Locker directory already exists"
        info "Repository appears to be unlocked"
        return 0
    fi

    # Determine key file path, preferring env var if set, otherwise derive it
    local key_file="${PADLOCK_KEY_FILE:-}"
    if [[ -z "$key_file" ]]; then
        local repo_root
        repo_root=$(_get_repo_root .)
        key_file="$PADLOCK_KEYS/$(basename "$repo_root").key"

        if [[ ! -f "$key_file" ]]; then
            error "Could not find default decryption key for this repository."
            info "Looked for key at: $key_file"
            info "You can also set the PADLOCK_KEY_FILE environment variable manually."
            return 1
        fi
        trace "Using derived repository key: $key_file"
    else
        trace "Using key from PADLOCK_KEY_FILE env var: $key_file"
    fi

    lock "üîì Decrypting $locker_age_file..."

    # Decrypt and extract using the determined key file
    if age -d -i "$key_file" < "$locker_age_file" | tar -xzf -; then
        local file_count
        file_count=$(find locker -type f | wc -l)
        okay "‚úì Unlocked: $locker_age_file ‚Üí locker/ ($file_count files)"

        # Verify integrity against the stored checksum
        if [[ -f "$checksum_file" ]]; then
            local expected_checksum
            expected_checksum=$(cat "$checksum_file")
            local current_checksum
            current_checksum=$(_calculate_locker_checksum "locker")

            trace "Verifying checksum. Expected: $expected_checksum, Current: $current_checksum"
            if [[ "$expected_checksum" == "$current_checksum" ]]; then
                okay "‚úì Locker integrity verified."
            else
                error "üîí Integrity check FAILED. Contents may have been tampered with."
                info "Expected: $expected_checksum"
                info "Current:  $current_checksum"
                if [[ "${opt_force:-0}" -eq 1 ]]; then
                    warn "‚ö†Ô∏è  --force flag used, continuing despite integrity failure"
                else
                    fatal "Use --force to override integrity check and unlock anyway"
                fi
            fi
        fi

        # Restore mapped files from locker/map to their original locations
        if [[ -f "locker/padlock.map" ]]; then
            info "üìã Restoring mapped files to original locations..."
            local restored_count=0
            
            while IFS='|' read -r src_rel dest_rel checksum; do
                # Skip comments and empty lines
                [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
                [[ -z "$src_rel" ]] && continue
                
                local stored_file="locker/map/$src_rel"
                local restore_path="$PWD/$dest_rel"
                
                if [[ -f "$stored_file" ]]; then
                    # Restore regular file
                    mkdir -p "$(dirname "$restore_path")"
                    cp "$stored_file" "$restore_path"
                    okay "‚úì Restored file: $dest_rel"
                    ((restored_count++))
                elif [[ -f "locker/map/$(basename "$src_rel").tar.gz" ]] || [[ -f "locker/map/$(dirname "$src_rel")/$(basename "$src_rel").tar.gz" ]]; then
                    # Find the tar file (could be in map root or subdirectory)
                    local tar_file=""
                    if [[ -f "locker/map/$(basename "$src_rel").tar.gz" ]]; then
                        tar_file="locker/map/$(basename "$src_rel").tar.gz"
                    else
                        tar_file="locker/map/$(dirname "$src_rel")/$(basename "$src_rel").tar.gz"
                    fi
                    
                    # Extract directly to repository root
                    if tar -xzf "$tar_file" -C "$PWD" 2>/dev/null; then
                        okay "‚úì Restored directory: $dest_rel"
                        ((restored_count++))
                    else
                        warn "Failed to extract: $tar_file"
                    fi
                else
                    warn "Mapped item not found in locker/map, skipping: $src_rel"
                fi
            done < "locker/padlock.map"
            
            # Move padlock.map back to root
            cp "locker/padlock.map" "padlock.map"
            rm -f "locker/padlock.map"
            
            # Clean up map directory from locker
            rm -rf "locker/map"
            
            if [[ $restored_count -gt 0 ]]; then
                info "üìÅ Restored $restored_count mapped items to original locations"
            fi
        fi

        # Clean up encrypted file and state indicators
        rm -f "$locker_age_file" "$locked_file" "$checksum_file"
        
        # Remove .chest directory when unlocked (should be empty after cleanup)
        if [[ -d ".chest" ]]; then
            # Force removal of any remaining files in .chest and the directory itself
            rm -rf ".chest"
            trace "Removed .chest directory"
        fi

        info "Repository unlocked successfully. Your shell session is not affected."
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Edit files in the 'locker' directory."
        echo "  ‚Ä¢ Run 'git commit' to auto-lock when done."
        warn "‚ö†Ô∏è  Secrets are now in plaintext. The 'locker/' directory is in .gitignore."

    else
        fatal "Failed to decrypt $locker_age_file. Check your key permissions or repository state."

    fi
}

do_clean_manifest() {
    local manifest_file="$PADLOCK_ETC/manifest.txt"

    if [[ ! -f "$manifest_file" || ! -s "$manifest_file" ]]; then
        info "Manifest is empty or not found. Nothing to clean."
        return
    fi

    local temp_file
    temp_file=$(_temp_mktemp)

    # Preserve header
    grep "^#" "$manifest_file" > "$temp_file"

    # Use a temporary variable to store the lines to keep
    local lines_to_keep=""
    while IFS= read -r line; do
        # Skip comments
        [[ "$line" =~ ^# ]] && continue

        # Parse the line
        IFS='|' read -r namespace name path type remote checksum created access metadata <<< "$line"

        # Keep if the path exists and is not a temp path
        if [[ -d "$path" && "$metadata" != *"temp=true"* && "$path" != */tmp/* ]]; then
            lines_to_keep+="$line\n"
        else
            trace "Pruning from manifest: $namespace/$name ($path)"
        fi
    done < "$manifest_file"

    # Write the kept lines to the temp file
    printf "%b" "$lines_to_keep" >> "$temp_file"

    mv "$temp_file" "$manifest_file"
    okay "‚úì Manifest cleaned"
}

do_list() {
    local filter="$1"
    local manifest_file="$PADLOCK_ETC/manifest.txt"

    if [[ ! -f "$manifest_file" || ! -s "$manifest_file" ]]; then
        info "Manifest is empty or not found. No repositories tracked yet."
        return
    fi

    case "$filter" in
        --all)
            awk -F'|' '!/^#/ { printf "%-15s %-20s %s (%s)\n", $1, $2, $3, $4 }' "$manifest_file"
            ;;
        --ignition)
            awk -F'|' '!/^#/ && $4 == "ignition" && $9 !~ /temp=true/ { printf "%-15s %-20s %s\n", $1, $2, $3 }' "$manifest_file"
            ;;
        --namespace)
            local ns="$2"
            awk -F'|' -v namespace="$ns" '!/^#/ && $1 == namespace && $9 !~ /temp=true/ { printf "%-20s %s (%s)\n", $2, $3, $4 }' "$manifest_file"
            ;;
        *)
            # Default: exclude temp directories, show namespace/name/path
            awk -F'|' '!/^#/ && $9 !~ /temp=true/ && $3 !~ /\/tmp\// { printf "%-15s %-20s %s (%s)\n", $1, $2, $3, $4 }' "$manifest_file"
            ;;
    esac
}

do_ls() {
    local target="${1:-}"
    
    case "$target" in
        master)
            # Show master key path and status
            info "üîë Master key information:"
            echo
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                okay "‚úì Master key exists: $PADLOCK_GLOBAL_KEY"
                local key_size
                key_size=$(wc -c < "$PADLOCK_GLOBAL_KEY" 2>/dev/null)
                trace "   Size: $key_size bytes"
                
                # Show creation time if available
                if command -v stat >/dev/null 2>&1; then
                    local created
                    if stat --version >/dev/null 2>&1; then
                        # GNU stat
                        created=$(stat -c %y "$PADLOCK_GLOBAL_KEY" 2>/dev/null | cut -d. -f1)
                    else
                        # BSD stat (macOS)
                        created=$(stat -f "%Sm" "$PADLOCK_GLOBAL_KEY" 2>/dev/null)
                    fi
                    [[ -n "$created" ]] && trace "   Created: $created"
                fi
                
                # Show public key
                if command -v age-keygen >/dev/null 2>&1; then
                    local pubkey
                    pubkey=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null || echo "Unable to read")
                    info "üîê Public key: $pubkey"
                fi
            else
                error "‚ùå Master key not found: $PADLOCK_GLOBAL_KEY"
                info "Create with: padlock key --generate-global"
            fi
            
            # Check for ignition backup
            local skull_backup="$PADLOCK_KEYS/skull.age"
            if [[ -f "$skull_backup" ]]; then
                okay "üíÄ Skull backup exists: $skull_backup"
            else
                warn "‚ö†Ô∏è  No skull backup found: $skull_backup"
                info "Create with: padlock setup (in interactive mode)"
            fi
            ;;
        *)
            error "Unknown ls target: $target"
            info "Available targets:"
            info "  master  - Show master key path and status"
            return 1
            ;;
    esac
}

# Backup critical repository artifacts
_backup_repo_artifacts() {
    local repo_path="$1"
    local repo_name=$(basename "$repo_path")
    
    # Determine namespace from git remote or use 'local'
    local namespace="local"
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Parse remote URL to extract host, user, and repo
            local host user_repo
            if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
                # HTTPS: https://github.com/user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
                # SSH: git@github.com:user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            else
                # Fallback for unusual formats
                host="unknown"
                user_repo=$(basename "$repo_path")
            fi
            
            # Create namespace as host, repo as user/repo to avoid collisions
            namespace="$host"
            repo_name="$user_repo"
        fi
    fi
    
    local backup_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
    
    mkdir -p "$backup_dir"
    
    local artifacts_backed_up=0
    
    # Backup padlock.map if it exists
    if [[ -f "$repo_path/padlock.map" ]]; then
        cp "$repo_path/padlock.map" "$backup_dir/padlock.map"
        ((artifacts_backed_up++))
        trace "Backed up padlock.map"
    fi
    
    # Backup .gitattributes (padlock-specific parts)
    if [[ -f "$repo_path/.gitattributes" ]]; then
        grep -E "(locker\.age|filter=locker-crypt|bin/\*|\.githooks/\*)" "$repo_path/.gitattributes" > "$backup_dir/.gitattributes" 2>/dev/null || true
        if [[ -s "$backup_dir/.gitattributes" ]]; then
            ((artifacts_backed_up++))
            trace "Backed up .gitattributes (padlock sections)"
        else
            rm -f "$backup_dir/.gitattributes"
        fi
    fi
    
    # Backup padlock-specific .gitignore sections
    if [[ -f "$repo_path/.gitignore" ]]; then
        grep -A5 -B1 "# Padlock" "$repo_path/.gitignore" > "$backup_dir/.gitignore" 2>/dev/null || true
        if [[ -s "$backup_dir/.gitignore" ]]; then
            ((artifacts_backed_up++))
            trace "Backed up .gitignore (padlock sections)"
        else
            rm -f "$backup_dir/.gitignore"
        fi
    fi
    
    # Create artifact metadata
    if [[ $artifacts_backed_up -gt 0 ]]; then
        cat > "$backup_dir/.artifact_info" << EOF
# Padlock Repository Artifacts Backup
# Repository: $repo_name
# Path: $repo_path
# Backed up: $(date -Iseconds)
# Artifacts: $artifacts_backed_up

artifacts_count=$artifacts_backed_up
repo_path=$repo_path
backup_date=$(date -Iseconds)
EOF
        trace "Artifact backup complete: $artifacts_backed_up items"
    else
        # Remove empty backup directory
        rmdir "$backup_dir" 2>/dev/null || true
    fi
    
    return 0
}

# Restore critical repository artifacts
_restore_repo_artifacts() {
    local repo_path="$1"
    local repo_name=$(basename "$repo_path")
    
    # Determine namespace from git remote or use 'local'
    local namespace="local"
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Parse remote URL to extract host, user, and repo
            local host user_repo
            if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
                # HTTPS: https://github.com/user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
                # SSH: git@github.com:user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            else
                # Fallback for unusual formats
                host="unknown"
                user_repo=$(basename "$repo_path")
            fi
            
            # Create namespace as host, repo as user/repo to avoid collisions
            namespace="$host"
            repo_name="$user_repo"
        fi
    fi
    
    local backup_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
    
    if [[ ! -d "$backup_dir" ]]; then
        return 1  # No artifacts backed up
    fi
    
    local artifacts_restored=0
    
    info "üîß Restoring backed up artifacts..."
    
    # Restore padlock.map
    if [[ -f "$backup_dir/padlock.map" && ! -f "$repo_path/padlock.map" ]]; then
        cp "$backup_dir/padlock.map" "$repo_path/padlock.map"
        ((artifacts_restored++))
        okay "‚úì Restored padlock.map"
    fi
    
    # Restore .gitattributes (merge approach)
    if [[ -f "$backup_dir/.gitattributes" ]]; then
        if [[ ! -f "$repo_path/.gitattributes" ]]; then
            cp "$backup_dir/.gitattributes" "$repo_path/.gitattributes"
            ((artifacts_restored++))
            okay "‚úì Restored .gitattributes"
        else
            # Check if padlock sections are missing and add them
            if ! grep -q "locker.age" "$repo_path/.gitattributes" 2>/dev/null; then
                echo "" >> "$repo_path/.gitattributes"
                cat "$backup_dir/.gitattributes" >> "$repo_path/.gitattributes"
                ((artifacts_restored++))
                okay "‚úì Merged padlock sections into .gitattributes"
            fi
        fi
    fi
    
    # Restore .gitignore (merge approach)
    if [[ -f "$backup_dir/.gitignore" ]]; then
        if [[ ! -f "$repo_path/.gitignore" ]]; then
            cp "$backup_dir/.gitignore" "$repo_path/.gitignore"
            ((artifacts_restored++))
            okay "‚úì Restored .gitignore"
        else
            # Check if padlock sections are missing and add them
            if ! grep -q "# Padlock" "$repo_path/.gitignore" 2>/dev/null; then
                echo "" >> "$repo_path/.gitignore"
                cat "$backup_dir/.gitignore" >> "$repo_path/.gitignore"
                ((artifacts_restored++))
                okay "‚úì Merged padlock sections into .gitignore"
            fi
        fi
    fi
    
    if [[ $artifacts_restored -gt 0 ]]; then
        info "üìÅ Restored $artifacts_restored artifacts from backup"
        return 0
    else
        return 1
    fi
}

# Enhanced manifest management
_add_to_manifest() {
    local repo_path="$1"
    local repo_type="${2:-standard}"
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    local now
    now=$(date -Iseconds 2>/dev/null || date)
    
    # Create header if empty
    if [[ ! -s "$manifest_file" ]]; then
        mkdir -p "$(dirname "$manifest_file")"
        echo "# Padlock Repository Manifest v2.0" > "$manifest_file"
        echo "# Format: namespace|name|path|type|remote|checksum|created|last_access|metadata" >> "$manifest_file"
    fi
    
    # Extract repository information
    local repo_name
    repo_name=$(basename "$repo_path")
    local namespace="local"
    local remote_url=""
    local checksum=""
    
    # Get git remote if available
    if [[ -d "$repo_path/.git" ]]; then
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Extract namespace and repo name from remote URL
            if [[ "$remote_url" =~ github\.com[/:]([^/]+)/([^/]+) ]]; then
                namespace="${BASH_REMATCH[1]}"
                repo_name="${BASH_REMATCH[2]%.git}"
            elif [[ "$remote_url" =~ gitlab\.com[/:]([^/]+)/([^/]+) ]]; then
                namespace="${BASH_REMATCH[1]}"
                repo_name="${BASH_REMATCH[2]%.git}"
            else
                namespace="remote"
            fi
        fi
    fi
    
    # Generate repository checksum for integrity tracking
    checksum=$(echo "$repo_path|$repo_type|$now" | sha256sum | cut -d' ' -f1 | head -c 12)
    
    # Skip if path already exists in manifest
    if grep -q "|$repo_path|" "$manifest_file" 2>/dev/null; then
        trace "Manifest entry for $repo_path already exists. Skipping."
        return 0
    fi

    # Detect temp directories to add metadata
    local metadata=""
    if [[ "$repo_path" == */tmp/* ]] || [[ "$repo_path" == */temp/* ]]; then
        metadata="temp=true"
    fi


    # Add new entry
    echo "$namespace|$repo_name|$repo_path|$repo_type|$remote_url|$checksum|$now|$now|$metadata" >> "$manifest_file"
    trace "Added manifest entry for $repo_path"
}

# Master unlock command
do_master_unlock() {
    # Check if already unlocked
    local repo_root="$(_get_repo_root .)"
    local state="$(_get_lock_state "$repo_root")"
    
    if [[ "$state" == "unlocked" ]]; then
        warn "‚ö†Ô∏è  Repository is already unlocked"
        info "üìÅ Locker directory exists and is accessible"
        return 0
    fi
    
    lock "üîë Unlocking with master key..."
    if ! _master_unlock; then
        return 1
    fi
    
    okay "‚úì Repository unlocked with master key"
    info "üìù Environment loaded and ready"
    warn "‚ö†Ô∏è  Secrets are now in plaintext - DO NOT commit locker/"
}

_master_unlock() {
    # Check if the global key exists
    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        error "Master key not found at: $PADLOCK_GLOBAL_KEY"
        info "Options to resolve this:"
        info "  ‚Ä¢ Run 'padlock key --generate-global' to create a new master key"
        info "  ‚Ä¢ Run 'padlock key restore' if you have a skull backup"
        info "  ‚Ä¢ Run 'padlock setup' for interactive setup"
        return 1
    fi

    local encrypted_file=""
    local is_chest_mode=false
    
    # Check for chest mode first, then legacy mode
    if [[ -f ".chest/locker.age" ]]; then
        encrypted_file=".chest/locker.age"
        is_chest_mode=true
        info "Found chest mode encrypted locker"
    elif [[ -f "locker.age" ]]; then
        encrypted_file="locker.age"
        info "Found legacy mode encrypted locker"
    else
        error "No encrypted locker found (locker.age or .chest/locker.age missing)."
        info "Cannot perform master unlock without encrypted locker."
        return 1
    fi

    # Use the global key for decryption by setting AGE_KEY_FILE for __decrypt_stream
    export PADLOCK_KEY_FILE="$PADLOCK_GLOBAL_KEY"

    info "Attempting decryption with master key..."
    if __decrypt_stream < "$encrypted_file" | tar -xzf -; then
        local file_count
        file_count=$(find locker -type f | wc -l)
        okay "‚úì Unlocked: $encrypted_file ‚Üí locker/ ($file_count files)"
        
        # Restore mapped files from locker/map to their original locations
        if [[ -f "locker/padlock.map" ]]; then
            info "üìã Restoring mapped files to original locations..."
            local restored_count=0
            
            while IFS='|' read -r src_rel dest_rel checksum; do
                # Skip comments and empty lines
                [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
                [[ -z "$src_rel" ]] && continue
                
                local stored_file="locker/map/$src_rel"
                local restore_path="$PWD/$dest_rel"
                
                if [[ -f "$stored_file" ]]; then
                    # Restore regular file
                    mkdir -p "$(dirname "$restore_path")"
                    cp "$stored_file" "$restore_path"
                    okay "‚úì Restored file: $dest_rel"
                    ((restored_count++))
                elif [[ -f "locker/map/$(basename "$src_rel").tar.gz" ]] || [[ -f "locker/map/$(dirname "$src_rel")/$(basename "$src_rel").tar.gz" ]]; then
                    # Find the tar file (could be in map root or subdirectory)
                    local tar_file=""
                    if [[ -f "locker/map/$(basename "$src_rel").tar.gz" ]]; then
                        tar_file="locker/map/$(basename "$src_rel").tar.gz"
                    else
                        tar_file="locker/map/$(dirname "$src_rel")/$(basename "$src_rel").tar.gz"
                    fi
                    
                    # Extract directly to repository root
                    if tar -xzf "$tar_file" -C "$PWD" 2>/dev/null; then
                        okay "‚úì Restored directory: $dest_rel"
                        ((restored_count++))
                    else
                        warn "Failed to extract: $tar_file"
                    fi
                else
                    warn "Mapped item not found in locker/map, skipping: $src_rel"
                fi
            done < "locker/padlock.map"
            
            # Move padlock.map back to root
            cp "locker/padlock.map" "padlock.map"
            rm -f "locker/padlock.map"
            
            # Clean up map directory from locker
            rm -rf "locker/map"
            
            if [[ $restored_count -gt 0 ]]; then
                info "üìÅ Restored $restored_count mapped items to original locations"
            fi
        fi
        
        if [[ "$is_chest_mode" == true ]]; then
            # In chest mode, remove the entire .chest directory after successful unlock
            rm -rf .chest
            info "Successfully unlocked chest with master key."
        else
            # In legacy mode, remove the encrypted file and lock marker
            rm -f locker.age .locked
            info "Successfully unlocked with master key."
        fi
        unset PADLOCK_KEY_FILE
        return 0
    else
        error "Failed to decrypt encrypted locker with master key."
        unset PADLOCK_KEY_FILE
        return 1
    fi
}

# Placeholders for unimplemented ignition features
_ignition_lock() {
    local repo_root="$(_get_repo_root .)"
    
    # Check if we have a locker to lock
    if [[ ! -d "$repo_root/locker" ]]; then
        error "No locker directory found"
        info "Repository may already be locked"
        return 1
    fi
    
    # Check if we're in chest mode
    if [[ ! -d "$repo_root/.chest" ]]; then
        error "Repository is not in chest mode"
        info "Use 'padlock ignite --status' to check current state"
        return 1
    fi
    
    lock "üóÉÔ∏è  Locking locker into chest..."
    
    # Use the existing _lock_chest helper which does the actual work
    if _lock_chest; then
        okay "‚úì Locker secured in chest"
        info "üî• Ignition key required for unlock"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ git add . && git commit"
        echo "  ‚Ä¢ To unlock: padlock ignite --unlock"
        warn "‚ö†Ô∏è  Chest is now locked and safe to commit"
        return 0
    else
        error "Failed to lock locker into chest"
        return 1
    fi
}
_chest_status() {
    local repo_root="$(_get_repo_root .)"
    
    if [[ ! -d "$repo_root/.chest" ]]; then
        error "Repository is not in chest mode"
        info "This repository uses standard locker encryption"
        return 1
    fi
    
    info "=== Chest Status ==="
    
    local chest_blob="$repo_root/.chest/locker.age"
    local ignition_blob="$repo_root/.chest/ignition.age"
    
    if [[ -f "$chest_blob" && -f "$ignition_blob" ]]; then
        local size
        size=$(du -h "$chest_blob" 2>/dev/null | cut -f1)
        warn "üóÉÔ∏è  CHEST LOCKED"
        info "Encrypted locker: $size"
        info "Ignition key: protected"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ To unlock: padlock ignite --unlock"
        echo "  ‚Ä¢ Set ignition key: export PADLOCK_IGNITION_PASS='your-key'"
        
    elif [[ -d "$repo_root/locker" ]]; then
        okay "üîì CHEST UNLOCKED"
        local file_count
        file_count=$(find "$repo_root/locker" -type f | wc -l)
        info "Files accessible: $file_count"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Edit files in locker/"
        echo "  ‚Ä¢ To lock: padlock ignite --lock"
        echo "  ‚Ä¢ Manual commit locks automatically"
        
    else
        error "üîß CHEST CORRUPTED"
        warn "Neither locked chest nor unlocked locker found"
        echo
        printf "%bNext steps:%b\n" "$cyan" "$xx"
        echo "  ‚Ä¢ Try: padlock repair"
        echo "  ‚Ä¢ Check ignition key: PADLOCK_IGNITION_PASS"
        echo "  ‚Ä¢ Or convert: padlock revoke --ignition"
    fi
    
    # Show chest contents if accessible
    if [[ -d "$repo_root/.chest" ]]; then
        local chest_items
        chest_items=$(find "$repo_root/.chest" -type f 2>/dev/null | wc -l)
        trace "üóÉÔ∏è  Chest items: $chest_items"
    fi
}

_ignition_unlock() {
    local ignition_pass="${PADLOCK_IGNITION_PASS:-}"
    
    if [[ -z "$ignition_pass" ]]; then
        error "Ignition passphrase not found in environment variable PADLOCK_IGNITION_PASS."
        info "Usage: PADLOCK_IGNITION_PASS='your-phrase' padlock ignite --unlock"
        return 1
    fi

    # Check for chest pattern
    local encrypted_file
    if [[ -f ".chest/locker.age" ]]; then
        encrypted_file=".chest/locker.age"
    elif [[ -f "locker.age" ]]; then
        encrypted_file="locker.age"
    else
        error "No encrypted locker found."
        return 1
    fi
    
    # Verify we have the ignition key file
    local ignition_key_file=".chest/ignition.key"
    if [[ ! -f "$ignition_key_file" ]]; then
        error "Ignition key file not found at $ignition_key_file"
        info "Repository may not be in ignition mode"
        return 1
    fi
    
    # Verify the passphrase matches what was used during setup
    if [[ -f ".chest/ignition.ref" ]]; then
        local stored_ref=$(cat ".chest/ignition.ref")
        local stored_pass="${stored_ref%%:*}"
        if [[ "$ignition_pass" != "$stored_pass" ]]; then
            error "Invalid ignition passphrase"
            return 1
        fi
    fi

    # Use the ignition private key to decrypt (not passphrase mode)
    if age -d -i "$ignition_key_file" < "$encrypted_file" | tar -xzf -; then
        rm -f "$encrypted_file" .locked
        [[ -d ".chest" ]] && rm -rf .chest
        okay "‚úì Repository unlocked with ignition key"
        return 0
    else
        error "Failed to decrypt with ignition key."
        return 1
    fi
}

# Ignition unlock command


# FUNC_META | src:/home/xnull/repos/shell/bashfx/fx-padlock/parts/06_api.sh | src_sum:b97126810ebbae2e590a2595eae117380fd344ec8c170898f63d259286374a1e | orig:do_ignite | edit:do_ignite_enhanced | orig_sum:c42538144aad062f778e2c35cab6d09bd09ceb149ca9bfcba3cd1e7cc5a47acc
do_ignite() {
    local action="$1"; shift || { _ignite_help; return 1; }
    
    # Set REPO_ROOT for the helpers, as this is a top-level command.
    REPO_ROOT=$(_get_repo_root .)

    # BashFX v3.0 Staged Parsing: Validate command exists before parsing
    case "$action" in
        create|new|unlock|list|status|allow|revoke|rotate|reset|verify|export|help) ;;
        --unlock|-u|--lock|-l|--status|-s) ;; # Legacy chest operations
        *) error "Unknown ignite action: $action"; _ignite_help; return 1 ;;
    esac
    
    # Route to specialized handlers using BashFX v3.0 pattern
    "_do_ignite_$action" "$@"
}

# Smart Environment Strategy for secure passphrase handling
_get_ignite_passphrase() {
    local name="$1"
    local provided="${2:-}"
    
    # Priority: CLI arg > specific env > generic env > interactive
    if [[ -n "$provided" ]]; then
        echo "$provided"
    elif [[ -n "$PADLOCK_IGNITION_PASS" ]]; then
        echo "$PADLOCK_IGNITION_PASS"          # Generic
    else
        # For now, require explicit passphrase or environment variable
        error "Missing passphrase for unlock operation"
        info "Set: export PADLOCK_IGNITION_PASS='your-passphrase'"
        info "Or: export PADLOCK_IGNITION_PASS_${name//-/_}='specific-passphrase'"
        return 1
    fi
}

# BashFX v3.0 Argument Parser for ignite commands
_parse_ignite_command_args() {
    local command="$1"; shift
    
    # Initialize parsed variables
    PARSED_NAME=""
    PARSED_PASSPHRASE=""
    PARSED_KEY_PATH=""
    PARSED_PUBKEY=""
    
    case "$command" in
        create)
            PARSED_NAME="${1:-default}"
            shift 2>/dev/null || true
            _extract_flag_values "$@"
            ;;
        new)
            _extract_flag_values "$@"
            if [[ -z "$PARSED_NAME" ]]; then
                error "Missing --name parameter"
                info "Usage: padlock ignite new --name=ai-bot [--phrase=...]"
                return 1
            fi
            ;;
        unlock)
            PARSED_NAME="${1:-default}"
            shift 2>/dev/null || true
            _extract_flag_values "$@"
            ;;
        verify)
            _extract_flag_values "$@"
            if [[ -z "$PARSED_KEY_PATH" ]]; then
                error "Missing --key parameter" 
                info "Usage: padlock ignite verify --key=/path/to/key [--phrase=...]"
                return 1
            fi
            ;;
        allow)
            PARSED_PUBKEY="$1"
            if [[ -z "$PARSED_PUBKEY" ]]; then
                error "Missing public key parameter"
                info "Usage: padlock ignite allow <public-key>"
                return 1
            fi
            ;;
        revoke)
            _extract_flag_values "$@"
            if [[ -z "$PARSED_NAME" ]]; then
                error "Missing --name parameter"
                info "Usage: padlock ignite revoke --name=ai-bot"
                return 1
            fi
            ;;
    esac
    return 0
}

# Helper function to extract flag values using BashFX v3.0 pattern
_extract_flag_values() {
    local args=("$@")
    for ((i=0; i<${#args[@]}; i++)); do
        case "${args[i]}" in
            --name=*)
                PARSED_NAME="${args[i]#*=}"
                ;;
            --phrase=*|--passphrase=*)
                PARSED_PASSPHRASE="${args[i]#*=}"
                ;;
            --key=*)
                PARSED_KEY_PATH="${args[i]#*=}"
                ;;
        esac
    done
}

# TTY Integration Abstraction Layer
_ignite_operation() {
    local operation="$1"    # create_master|create_distro|unlock
    local name="$2"
    local passphrase="$3"
    
    case "$operation" in
        create_master)
            _create_ignition_master_with_tty_magic "$name" "$passphrase"
            ;;
        create_distro)
            _create_ignition_distro_with_tty_magic "$name" "$passphrase"
            ;;
        unlock)
            _unlock_ignition_with_tty_magic "$name" "$passphrase"
            ;;
        *)
            error "Unknown ignition operation: $operation"
            return 1
            ;;
    esac
}

# AI-Optimized Help System following BashFX v3.0 pattern
_ignite_help() {
    case "${1:-}" in
        create)
            info "padlock ignite create [name] [--phrase=...]"
            info "Create repo-ignition master key (I key) that establishes authority"
            ;;
        new)
            info "padlock ignite new --name=NAME [--phrase=...]"
            info "Create distributed ignition key (D key) controlled by master"
            ;;
        unlock)
            info "padlock ignite unlock [name]"
            info "Unlock repository with distributed key using PADLOCK_IGNITION_PASS"
            ;;
        more)
            _ignite_help_detailed  # Full help for humans
            ;;
        "")
            info "Ignition System Commands: create, new, unlock, list, status, allow, revoke, export, verify"
            info "Use 'padlock help ignite more' for detailed help"
            ;;
    esac
}

_ignite_help_detailed() {
    info "Ignition System Commands:"
    info ""
    info "Repository Owner Commands:"
    info "  create [name] [--phrase=...]     Create repo-ignition master (I key)"
    info "  new --name=NAME [--phrase=...]   Create distributed key (D key)"  
    info "  export <name> --output=PATH      Export key to file with passphrase"
    info "  allow <pubkey>                   Grant access to public key"
    info "  revoke --name=NAME               Revoke distributed key"
    info "  rotate                           Rotate ignition master (invalidates all D keys)"
    info "  reset                            Remove ignition system completely"
    info ""
    info "Third-Party/AI Commands:"
    info "  unlock [name]                    Unlock repo with distributed key"
    info "  list                             List available ignition keys"
    info "  status                           Show ignition system status"
    info "  verify --key=PATH [--phrase=...] Test if key can access repository"
    info ""
    info "Legacy Chest Operations:"
    info "  --lock, -l                       Lock locker into chest"
    info "  --unlock, -u                     Unlock chest to locker"
    info "  --status, -s                     Show chest status"
}

# Core command implementations with full functionality
_do_ignite_create() {
    _parse_ignite_command_args "create" "$@" || return 1
    
    # Get passphrase using Smart Environment Strategy
    local passphrase=$(_get_ignite_passphrase "$PARSED_NAME" "$PARSED_PASSPHRASE")
    
    info "Creating repo-ignition master key (I key): $PARSED_NAME"
    info "This will establish authority over distributed keys"
    
    # Use TTY Integration Abstraction Layer
    _ignite_operation "create_master" "$PARSED_NAME" "$passphrase"
}

_do_ignite_new() {
    _parse_ignite_command_args "new" "$@" || return 1
    
    # Get passphrase using Smart Environment Strategy  
    local passphrase=$(_get_ignite_passphrase "$PARSED_NAME" "$PARSED_PASSPHRASE")
    
    info "Creating distributed ignition key (D key): $PARSED_NAME"
    info "This key will be controlled by the repo-ignition master"
    
    # Use TTY Integration Abstraction Layer
    _ignite_operation "create_distro" "$PARSED_NAME" "$passphrase"
}

_do_ignite_unlock() {
    _parse_ignite_command_args "unlock" "$@" || return 1
    
    # Get passphrase using Smart Environment Strategy
    local passphrase=$(_get_ignite_passphrase "$PARSED_NAME" "$PARSED_PASSPHRASE")
    
    if [[ -z "$passphrase" ]]; then
        error "Missing passphrase for unlock operation"
        info "Set: export PADLOCK_IGNITION_PASS='your-passphrase'"
        info "Or: export PADLOCK_IGNITION_PASS_$PARSED_NAME='specific-passphrase'"
        return 1
    fi
    
    info "Unlocking repository with distributed key: $PARSED_NAME"
    
    # Use TTY Integration Abstraction Layer
    _ignite_operation "unlock" "$PARSED_NAME" "$passphrase"
}

_do_ignite_allow() {
    _parse_ignite_command_args "allow" "$@" || return 1
    
    info "Allowing access for public key: ${PARSED_PUBKEY:0:20}..."
    info "This will grant repository access to the specified key"
    
    # TODO: Implement actual allow logic using Plan X winning approach
    info "[ENHANCED] Allow functionality - implementation pending Plan X integration"
    return 0
}

_do_ignite_list() {
    echo "Ignition Keys:"
    
    local ignition_dir="$REPO_ROOT/.padlock/ignition"
    if [[ ! -d "$ignition_dir" ]]; then
        echo "  No ignition system configured"
        return 0
    fi
    
    # List Repo-Ignition Master keys (I keys)
    echo "  Repo-Ignition Master (I):"
    local found_masters=false
    if [[ -d "$ignition_dir/keys" ]]; then
        for ikey in "$ignition_dir/keys"/*.ikey; do
            if [[ -f "$ikey" ]]; then
                local name=$(basename "$ikey" .ikey)
                local metadata="$ignition_dir/metadata/${name}.json"
                if [[ -f "$metadata" ]]; then
                    local created=$(grep '"created"' "$metadata" | cut -d'"' -f4 | cut -d'T' -f1 2>/dev/null || echo "unknown")
                    local status=$(grep '"status"' "$metadata" | cut -d'"' -f4 2>/dev/null || echo "unknown")
                    echo "    - $name (created: $created, status: $status)"
                    found_masters=true
                else
                    echo "    - $name (metadata missing)"
                    found_masters=true
                fi
            fi
        done
    fi
    if [[ "$found_masters" == false ]]; then
        echo "    - (none configured)"
    fi
    
    # List Distributed keys (D keys)
    echo "  Distributed Keys (D):"
    local found_distros=false
    if [[ -d "$ignition_dir/keys" ]]; then
        for dkey in "$ignition_dir/keys"/*.dkey; do
            if [[ -f "$dkey" ]]; then
                local name=$(basename "$dkey" .dkey)
                local metadata="$ignition_dir/metadata/${name}.json"
                if [[ -f "$metadata" ]]; then
                    local created=$(grep '"created"' "$metadata" | cut -d'"' -f4 | cut -d'T' -f1 2>/dev/null || echo "unknown")
                    local status=$(grep '"status"' "$metadata" | cut -d'"' -f4 2>/dev/null || echo "unknown")
                    echo "    - $name (created: $created, status: $status)"
                    found_distros=true
                else
                    echo "    - $name (metadata missing)"
                    found_distros=true
                fi
            fi
        done
    fi
    if [[ "$found_distros" == false ]]; then
        echo "    - (none configured)"
    fi
    
    return 0
}

_do_ignite_status() {
    info "Ignition System Status:"
    # TODO: Implement actual status checking using Plan X approach
    info "  Ignition Master (I): not configured"
    info "  Distributed Keys (D): 0 active, 0 revoked"
    info "  Repository Mode: standard (ignition disabled)"
    return 0
}

_do_ignite_export() {
    local key_name="" output_file="" phrase=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output=*) output_file="${1#*=}" ;;
            --phrase=*) phrase="${1#*=}" ;;
            --output) shift; output_file="$1" ;;
            --phrase) shift; phrase="$1" ;;
            --help|-h) 
                info "Usage: padlock ignite export <key-name> [--output=<file>] [--phrase=<passphrase>]"
                info "Export ignition key to portable file with passphrase encryption"
                info "  --output=FILE    Output file path (default: ./ignition.<key-name>.key)"
                info "  --phrase=PASS    Passphrase for encryption (or use PADLOCK_IGNITION_PASS)"
                return 0
                ;;
            -*) error "Unknown option: $1"; return 1 ;;
            *) [[ -z "$key_name" ]] && key_name="$1" || { error "Extra argument: $1"; return 1; } ;;
        esac
        shift
    done
    
    # Validate required arguments
    if [[ -z "$key_name" ]]; then
        error "Key name required"
        info "Usage: padlock ignite export <key-name> --output=<file> [--phrase=<passphrase>]"
        return 1
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="./ignition.${key_name}.key"
    fi
    
    # Load key bundle to get the key data
    _load_key_bundle "$key_name" || {
        error "Failed to load key: $key_name"
        return 1
    }
    
    local key_data="$LOADED_KEY_DATA"
    
    # Get passphrase if not provided
    if [[ -z "$phrase" ]]; then
        phrase=$(_get_ignite_passphrase "$key_name")
        if [[ -z "$phrase" ]]; then
            error "Passphrase required for export"
            info "Set PADLOCK_IGNITION_PASS or use --phrase=<passphrase>"
            return 1
        fi
    fi
    
    # Validate key data is present
    if [[ -z "$key_data" ]]; then
        error "Key data is empty for: $key_name"
        return 1
    fi
    
    # Export key with passphrase encryption metadata
    {
        echo "# ENCRYPTED WITH PASSPHRASE"
        echo "# This is a development placeholder - production should use age encryption"
        echo "# created: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        
        # Extract public key for reference (optional - don't fail if it errors)
        local pub_key
        if command -v age-keygen >/dev/null 2>&1; then
            local temp_key_file="/tmp/temp_export_$$"
            echo "$key_data" > "$temp_key_file"
            pub_key=$(age-keygen -y < "$temp_key_file" 2>/dev/null) || true
            rm -f "$temp_key_file"
            
            if [[ -n "$pub_key" ]]; then
                echo "# public key: $pub_key"
            fi
        fi
        
        # Include the private key data - this is the critical part
        echo "$key_data"
    } > "$output_file" || {
        error "Failed to write export file: $output_file"
        return 1
    }
    
    # Generate checksum
    local checksum
    checksum=$(md5sum "$output_file" | cut -d' ' -f1)
    
    info "‚úì Exported key to: $output_file"
    info "  Checksum: $checksum"
    info "  [SECURE] Key encrypted with passphrase"
    
    return 0
}

_do_ignite_revoke() {
    _parse_ignite_command_args "revoke" "$@" || return 1
    
    info "Revoking distributed key: $PARSED_NAME"
    info "This will permanently invalidate the key"
    
    # TODO: Implement actual revoke logic using Plan X approach
    info "[ENHANCED] Revoke functionality - implementation pending Plan X integration"
    return 0
}

_do_ignite_rotate() {
    info "Rotating ignition master key"
    info "WARNING: This will invalidate ALL distributed keys!"
    info "All third-party access will need to be re-established"
    
    # TODO: Implement actual rotate logic using Plan X approach  
    info "[ENHANCED] Rotate functionality - implementation pending Plan X integration"
    return 0
}

_do_ignite_reset() {
    info "Resetting ignition system"
    info "WARNING: This will remove ALL ignition infrastructure!"
    info "Repository will revert to standard key-only access"
    
    # TODO: Implement actual reset logic using Plan X approach
    info "[ENHANCED] Reset functionality - implementation pending Plan X integration"
    return 0
}

_do_ignite_verify() {
    _parse_ignite_command_args "verify" "$@" || return 1
    
    local key_path="$PARSED_KEY_PATH"
    local passphrase="$PARSED_PASSPHRASE"
    
    if [[ -z "$key_path" ]]; then
        error "Missing --key parameter"
        info "Usage: padlock ignite verify --key=/path/to/key [--phrase=...]"
        return 1
    fi
    
    if [[ ! -f "$key_path" ]]; then
        error "Key file not found: $key_path"
        return 1
    fi
    
    info "Verifying ignition key: $key_path"
    
    # Load the key file
    local key_data=$(cat "$key_path")
    
    # Check if it's encrypted and needs passphrase
    if echo "$key_data" | grep -q "# ENCRYPTED WITH PASSPHRASE"; then
        if [[ -z "$passphrase" ]]; then
            error "Key is encrypted but no passphrase provided"
            info "Use: padlock ignite verify --key=$key_path --phrase=..."
            return 1
        fi
        # Extract the actual key from development format
        key_data=$(echo "$key_data" | grep -v "^#" | head -1)
        info "‚úì Successfully decrypted key with passphrase"
    fi
    
    # Verify it's a valid age key
    if echo "$key_data" | grep -q "AGE-SECRET-KEY"; then
        # Extract public key
        local temp_key=$(mktemp)
        echo "$key_data" > "$temp_key"
        
        if public_key=$(age-keygen -y < "$temp_key" 2>/dev/null); then
            info "‚úì Valid age key format"
            info "  Public key: $(echo "$public_key" | tr -d '\n')"
            
            # Check if this public key is known in our ignition system
            if [[ -d "$REPO_ROOT/.padlock/ignition/metadata" ]]; then
                local found_match=false
                for metadata in "$REPO_ROOT/.padlock/ignition/metadata"/*.json; do
                    if [[ -f "$metadata" ]]; then
                        local key_name=$(basename "$metadata" .json)
                        local stored_key_file="$REPO_ROOT/.padlock/ignition/keys/${key_name}.dkey"
                        if [[ -f "$stored_key_file" ]]; then
                            # Compare public keys (simplified check)
                            local stored_public=$(age-keygen -y < "$stored_key_file" 2>/dev/null | grep -v "^#" | head -1)
                            if [[ "$(echo "$public_key" | tr -d '\n')" == "$(echo "$stored_public" | tr -d '\n')" ]]; then
                                info "‚úì Key matches known ignition key: $key_name"
                                found_match=true
                                break
                            fi
                        fi
                    fi
                done
                
                if [[ "$found_match" == false ]]; then
                    info "‚ö† Key is valid but not registered in this repository's ignition system"
                    return 1
                fi
            else
                info "‚ö† No ignition system configured in this repository"
                return 1
            fi
        else
            error "Failed to extract public key"
            rm -f "$temp_key"
            return 1
        fi
        
        rm -f "$temp_key"
        info "‚úì Key verified: Can access this repository"
        return 0
    else
        error "Not a valid age ignition key"
        return 1
    fi
}

# Legacy chest operations (keep for compatibility)
_do_ignite_--unlock() { _unlock_chest; }
_do_ignite_-u() { _unlock_chest; }
_do_ignite_--lock() { _lock_chest; }
_do_ignite_-l() { _lock_chest; }
_do_ignite_--status() { _chest_status; }
_do_ignite_-s() { _chest_status; }

_do_ignite_help() { _ignite_help "$@"; }
_do_ignite_--help() { _ignite_help "$@"; }

# Placeholder implementations for TTY magic integration
# These will be implemented using Plan X winning approach
_create_ignition_master_with_tty_magic() {
    local name="$1"
    local passphrase="$2"
    
    trace "TTY magic: creating ignition master for $name"
    
    # Check if master key already exists
    if [[ -f "$REPO_ROOT/.padlock/ignition/keys/${name}.ikey" ]]; then
        error "Ignition master key '$name' already exists"
        return 1
    fi
    
    # Generate a new age key pair for the ignition master (I key)
    local temp_key=$(mktemp)
    local temp_pub=$(mktemp)
    
    # Generate age key
    age-keygen > "$temp_key" 2>/dev/null || {
        error "Failed to generate ignition master key"
        rm -f "$temp_key" "$temp_pub"
        return 1
    }
    
    # Extract public key  
    age-keygen -y < "$temp_key" > "$temp_pub" 2>/dev/null || {
        error "Failed to extract public key"
        rm -f "$temp_key" "$temp_pub"
        return 1
    }
    
    local private_key=$(cat "$temp_key")
    local public_key=$(cat "$temp_pub")
    
    # Clean up temp files
    rm -f "$temp_key" "$temp_pub"
    
    # For development: Store key with passphrase marker (TODO: implement proper age encryption)
    local key_bundle
    if [[ -n "$passphrase" ]]; then
        # Store key with passphrase metadata for now (TODO: proper encryption)
        # In production, this would use age encryption or similar
        key_bundle="# ENCRYPTED WITH PASSPHRASE
# This is a development placeholder - production should use age encryption
$private_key"
        trace "Development mode: Key stored with passphrase metadata"
    else
        # Store unencrypted if no passphrase
        key_bundle="$private_key"
    fi
    
    # Store the key bundle using our storage system
    _store_key_bundle "master" "$name" "$key_bundle" "$passphrase" || {
        error "Failed to store ignition master key"
        return 1
    }
    
    info "‚úì Ignition master key created: $name"
    info "  Public key: $(echo "$public_key" | tr -d '\n')"
    
    return 0
}

_create_ignition_distro_with_tty_magic() {
    local name="$1"
    local passphrase="$2"
    
    trace "TTY magic: creating distributed key for $name"
    
    # Check if distributed key already exists
    if [[ -f "$REPO_ROOT/.padlock/ignition/keys/${name}.dkey" ]]; then
        error "Distributed ignition key '$name' already exists"
        return 1
    fi
    
    # Generate a new age key pair for the distributed key (D key)
    local temp_key=$(mktemp)
    local temp_pub=$(mktemp)
    
    # Generate age key
    age-keygen > "$temp_key" 2>/dev/null || {
        error "Failed to generate distributed ignition key"
        rm -f "$temp_key" "$temp_pub"
        return 1
    }
    
    # Extract public key
    age-keygen -y < "$temp_key" > "$temp_pub" 2>/dev/null || {
        error "Failed to extract public key"
        rm -f "$temp_key" "$temp_pub"
        return 1
    }
    
    local private_key=$(cat "$temp_key")
    local public_key=$(cat "$temp_pub")
    
    # Clean up temp files
    rm -f "$temp_key" "$temp_pub"
    
    # For development: Store key with passphrase marker (TODO: implement proper age encryption)
    local key_bundle
    if [[ -n "$passphrase" ]]; then
        # Store key with passphrase metadata for now (TODO: proper encryption)
        key_bundle="# ENCRYPTED WITH PASSPHRASE
# This is a development placeholder - production should use age encryption
$private_key"
        trace "Development mode: Key stored with passphrase metadata"
    else
        # Store unencrypted if no passphrase
        key_bundle="$private_key"
    fi
    
    # Store the key bundle using our storage system
    _store_key_bundle "distro" "$name" "$key_bundle" "$passphrase" || {
        error "Failed to store distributed ignition key"
        return 1
    }
    
    # Export the key to current directory for third-party sharing
    local export_file="./ignition.${name}.key"
    echo "$key_bundle" > "$export_file" || {
        error "Failed to export distributed key to: $export_file"
        return 1
    }
    
    # Create MD5 checksum per requirements
    local checksum=$(md5sum "$export_file" | cut -d' ' -f1)
    
    info "‚úì Distributed ignition key created: $name"
    info "  Public key: $(echo "$public_key" | tr -d '\n')"
    info "  Key file: $export_file"
    info "  MD5 checksum: $checksum"
    
    return 0
}

_unlock_ignition_with_tty_magic() {
    local name="$1"  
    local passphrase="$2"
    
    trace "TTY magic: unlocking with key $name"
    
    # Load the key bundle using storage system
    _load_key_bundle "$name" "auto" || {
        error "Failed to load ignition key: $name"
        return 1
    }
    
    # Decrypt the key bundle if it's encrypted (development mode)
    local decrypted_key
    if echo "$LOADED_KEY_DATA" | grep -q "# ENCRYPTED WITH PASSPHRASE"; then
        if [[ -n "$passphrase" ]]; then
            # Extract the actual key from development format
            decrypted_key=$(echo "$LOADED_KEY_DATA" | grep -v "^#" | head -1)
            trace "Development mode: Extracted key from passphrase-protected format"
        else
            error "Key is encrypted but no passphrase provided"
            return 1
        fi
    else
        # Use key directly if not encrypted
        decrypted_key="$LOADED_KEY_DATA"
    fi
    
    # Verify the decrypted key is valid age format
    if echo "$decrypted_key" | grep -q "AGE-SECRET-KEY"; then
        info "‚úì Successfully unlocked ignition key: $name"
        info "  Key type: $LOADED_KEY_TYPE"
        
        # TODO: Use the decrypted key to unlock repository secrets
        # This would integrate with the existing padlock unlock mechanism
        info "  [PLACEHOLDER] Would unlock repository with decrypted key"
        
        return 0
    else
        error "Invalid key format after decryption"
        return 1
    fi
}

# ============================================================================
# IGNITION STORAGE ARCHITECTURE - TASK-003
# ============================================================================

_setup_ignition_directories() {
    local repo_root="${1:-$REPO_ROOT}"
    
    if [[ -z "$repo_root" ]]; then
        error "No repository root specified for ignition setup"
        return 1
    fi
    
    local padlock_dir="$repo_root/.padlock"
    local ignition_dir="$padlock_dir/ignition"
    
    # Create ignition directory structure per ROADMAP.md
    trace "Setting up ignition directories in $padlock_dir"
    
    mkdir -p "$ignition_dir/keys" || {
        error "Failed to create ignition keys directory"
        return 1
    }
    
    mkdir -p "$ignition_dir/metadata" || {
        error "Failed to create ignition metadata directory"  
        return 1
    }
    
    mkdir -p "$ignition_dir/metadata/cache" || {
        error "Failed to create ignition cache directory"
        return 1
    }
    
    mkdir -p "$ignition_dir/.derived" || {
        error "Failed to create derived keys directory"
        return 1
    }
    
    # Create ignition manifest if it doesn't exist
    local manifest="$ignition_dir/manifest.json"
    if [[ ! -f "$manifest" ]]; then
        trace "Creating ignition manifest: $manifest"
        cat > "$manifest" << 'EOF'
{
  "version": "1.0",
  "created": "",
  "updated": "",
  "repo_id": "",
  "master_key_fingerprint": "",
  "ignition_keys": {},
  "distro_keys": {}
}
EOF
        # Set creation timestamp
        local timestamp=$(date -Iseconds)
        sed -i "s/\"created\": \"\"/\"created\": \"$timestamp\"/" "$manifest"
        sed -i "s/\"updated\": \"\"/\"updated\": \"$timestamp\"/" "$manifest"
    fi
    
    info "‚úì Ignition directories ready: $ignition_dir"
    return 0
}

_create_ignition_metadata() {
    local key_type="$1"     # "master" or "distro"  
    local name="$2"
    local key_path="$3"
    local fingerprint="$4"
    local encrypted="${5:-true}"  # Default to encrypted
    
    local metadata_file="$REPO_ROOT/.padlock/ignition/metadata/${name}.json"
    local timestamp=$(date -Iseconds)
    
    trace "Creating metadata for $key_type key: $name"
    
    cat > "$metadata_file" << EOF
{
  "name": "$name",
  "type": "$key_type",
  "created": "$timestamp",
  "updated": "$timestamp",
  "key_file": "$(basename "$key_path")",
  "fingerprint": "$fingerprint",
  "encrypted": $encrypted,
  "status": "active",
  "authority": {
    "master_key": true,
    "repo_key": true
  },
  "usage": {
    "unlock_count": 0,
    "last_used": null
  }
}
EOF
    
    return 0
}

_store_key_bundle() {
    local key_type="$1"     # "master" or "distro"
    local name="$2"
    local key_data="$3"
    local passphrase="$4"
    
    _setup_ignition_directories "$REPO_ROOT" || return 1
    
    local key_extension
    case "$key_type" in
        master) key_extension=".ikey" ;;
        distro) key_extension=".dkey" ;;
        *) error "Invalid key type: $key_type"; return 1 ;;
    esac
    
    local key_file="$REPO_ROOT/.padlock/ignition/keys/${name}${key_extension}"
    
    trace "Storing $key_type key bundle: $name"
    
    # For now, store key data directly (TODO: encrypt with passphrase using TTY magic)
    echo "$key_data" > "$key_file" || {
        error "Failed to store key bundle: $key_file"
        return 1
    }
    
    # Create fingerprint (simplified - use first 16 chars of key data hash)
    local fingerprint=$(echo "$key_data" | sha256sum | cut -c1-16)
    
    # Determine if key was encrypted
    local encrypted_status="false"
    if [[ -n "$passphrase" ]]; then
        encrypted_status="true"
    fi
    
    # Create metadata with encryption status
    _create_ignition_metadata "$key_type" "$name" "$key_file" "$fingerprint" "$encrypted_status" || {
        error "Failed to create metadata for key: $name"
        return 1
    }
    
    info "‚úì Key bundle stored: $name ($key_type)"
    return 0
}

_load_key_bundle() {
    local name="$1"
    local key_type="${2:-auto}"  # "master", "distro", or "auto"
    
    # Auto-detect key type if not specified
    if [[ "$key_type" == "auto" ]]; then
        if [[ -f "$REPO_ROOT/.padlock/ignition/keys/${name}.ikey" ]]; then
            key_type="master"
        elif [[ -f "$REPO_ROOT/.padlock/ignition/keys/${name}.dkey" ]]; then
            key_type="distro"  
        else
            error "No ignition key found for: $name"
            return 1
        fi
    fi
    
    local key_extension
    case "$key_type" in
        master) key_extension=".ikey" ;;
        distro) key_extension=".dkey" ;;
        *) error "Invalid key type: $key_type"; return 1 ;;
    esac
    
    local key_file="$REPO_ROOT/.padlock/ignition/keys/${name}${key_extension}"
    local metadata_file="$REPO_ROOT/.padlock/ignition/metadata/${name}.json"
    
    if [[ ! -f "$key_file" ]]; then
        error "Key file not found: $key_file"
        return 1
    fi
    
    if [[ ! -f "$metadata_file" ]]; then
        error "Metadata file not found: $metadata_file"
        return 1
    fi
    
    trace "Loading $key_type key bundle: $name"
    
    # Export key data and metadata for caller
    LOADED_KEY_DATA=$(cat "$key_file")
    LOADED_KEY_METADATA=$(cat "$metadata_file")
    LOADED_KEY_TYPE="$key_type"
    
    return 0
}

do_rotate() {
    local target="$1"
    shift || true

    # Set REPO_ROOT for the helpers
    REPO_ROOT=$(_get_repo_root .)

    case "$target" in
        master)
            # padlock rotate master
            info "[STUB] Rotating master key"
            info "WARNING: This will invalidate ALL repository keys!"
            info "All repositories will need to be re-keyed"
            return 0
            ;;
            
        ignition)
            # padlock rotate ignition [name]
            local name="${1:-default}"
            info "[STUB] Rotating ignition key: $name"
            info "WARNING: This will invalidate related distributed keys!"
            return 0
            ;;
            
        distro)
            # padlock rotate distro [name]
            local name="$1"
            if [[ -z "$name" ]]; then
                error "Missing distro key name"
                info "Usage: padlock rotate distro <name>"
                return 1
            fi
            info "[STUB] Rotating distributed key: $name"
            return 0
            ;;
            
        # Legacy support
        -K|--ignition)
            _rotate_ignition_key
            ;;
            
        help|*)
            if [[ "$target" != "help" ]]; then
                error "Unknown target for rotate: $target"
            fi
            info "Rotation Commands:"
            info "  master              Rotate global master key (affects all repos)"
            info "  ignition [name]     Rotate ignition key (invalidates D keys)"
            info "  distro <name>       Rotate specific distributed key"
            info ""
            info "Legacy:"
            info "  --ignition          Legacy ignition rotation"
            return 0
            ;;
    esac
}


do_export() {
    local export_file="${1:-padlock_export_$(date +%Y%m%d_%H%M%S).tar.age}"
    local passphrase

    # Get passphrase from environment, file, or interactive prompt
    if [[ -n "${PADLOCK_PASSPHRASE:-}" ]]; then
        passphrase="$PADLOCK_PASSPHRASE"
    elif [[ -n "${PADLOCK_PASSPHRASE_FILE:-}" ]] && [[ -f "$PADLOCK_PASSPHRASE_FILE" ]]; then
        passphrase=$(cat "$PADLOCK_PASSPHRASE_FILE")
    elif [[ -t 0 ]] && [[ -t 1 ]]; then
        # Interactive mode
        read -sp "Create a passphrase for the export file: " passphrase
        echo
    else
        fatal "No passphrase provided. Set PADLOCK_PASSPHRASE environment variable or use PADLOCK_PASSPHRASE_FILE for automation."
    fi

    if [[ -z "$passphrase" ]]; then
        fatal "Passphrase cannot be empty."
    fi

    # Check if there is anything to export
    if [[ ! -d "$PADLOCK_KEYS" || -z "$(ls -A "$PADLOCK_KEYS")" ]]; then
        error "No keys found to export."
        return 1
    fi
    if [[ ! -f "$PADLOCK_ETC/manifest.txt" ]]; then
        error "Manifest not found. Nothing to export."
        return 1
    fi

    info "üì¶ Exporting padlock environment..."

    local temp_dir
    temp_dir=$(_temp_mktemp_d)
    trap 'rm -rf "$temp_dir"' RETURN

    local export_manifest="$temp_dir/manifest.txt"
    local keys_dir="$temp_dir/keys"

    # Copy manifest, keys, and repo artifacts to a temporary location
    cp "$PADLOCK_ETC/manifest.txt" "$export_manifest"
    cp -r "$PADLOCK_KEYS" "$keys_dir"
    
    # Copy repo artifacts if they exist
    if [[ -d "$PADLOCK_ETC/repos" ]]; then
        cp -r "$PADLOCK_ETC/repos" "$temp_dir/repos"
    fi

    # Create metadata file
    cat > "$temp_dir/export_info.json" << EOF
{
    "version": "1.0",
    "exported_at": "$(date -Iseconds)",
    "exported_by": "$(whoami)@$(hostname)",
    "padlock_version": "$PADLOCK_VERSION"
}
EOF

    # Create a tarball and encrypt it with the passphrase
    tar -C "$temp_dir" -czf - . | AGE_PASSPHRASE="$passphrase" age -p > "$export_file"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to create encrypted export file."
    fi

    okay "‚úì Padlock environment successfully exported to: $export_file"
    warn "‚ö†Ô∏è  Keep this file and your passphrase safe!"
}

_merge_manifests() {
    local import_manifest="$1"
    local current_manifest="$2"
    local temp_file
    temp_file=$(_temp_mktemp)

    # Preserve header from current manifest if it exists
    if [[ -f "$current_manifest" ]]; then
        grep "^#" "$current_manifest" > "$temp_file"
    else
        # Or take header from import file
        grep "^#" "$import_manifest" > "$temp_file"
    fi

    # Merge entries (avoid duplicates by checking path column, which is column 3)
    {
        grep -v "^#" "$current_manifest" 2>/dev/null || true
        grep -v "^#" "$import_manifest"
    } | sort -t'|' -k3,3 -u >> "$temp_file"

    mv "$temp_file" "$current_manifest"
}

do_import() {
    local import_file="$1"
    local merge_mode="${2:---merge}"
    local passphrase="${3:-}" # Accept passphrase as 3rd arg

    if [[ ! -f "$import_file" ]]; then
        fatal "Import file not found: $import_file"
    fi

    if [[ -z "$passphrase" ]]; then
        # Get passphrase from environment, file, or interactive prompt
        if [[ -n "${PADLOCK_PASSPHRASE:-}" ]]; then
            passphrase="$PADLOCK_PASSPHRASE"
        elif [[ -n "${PADLOCK_PASSPHRASE_FILE:-}" ]] && [[ -f "$PADLOCK_PASSPHRASE_FILE" ]]; then
            passphrase=$(cat "$PADLOCK_PASSPHRASE_FILE")
        elif [[ -t 0 ]] && [[ -t 1 ]]; then
            read -sp "Enter passphrase for import file: " passphrase
            echo
        else
            fatal "No passphrase provided. Set PADLOCK_PASSPHRASE environment variable or use PADLOCK_PASSPHRASE_FILE for automation."
        fi
        
        if [[ -z "$passphrase" ]]; then
            fatal "Passphrase cannot be empty."
        fi
    fi

    local temp_dir
    temp_dir=$(_temp_mktemp_d)
    trap 'rm -rf "$temp_dir"' RETURN

    # Decrypt and extract
    if ! AGE_PASSPHRASE="$passphrase" age -d < "$import_file" | tar -C "$temp_dir" -xzf -; then
        fatal "Failed to decrypt import file (wrong passphrase?)"
    fi

    # Validate import
    if [[ ! -f "$temp_dir/export_info.json" || ! -f "$temp_dir/manifest.txt" ]]; then
        fatal "Invalid padlock export file."
    fi

    info "Successfully decrypted export file."

    # Backup current state
    local backup_dir="$PADLOCK_ETC/backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    if [[ -d "$PADLOCK_ETC" ]]; then
        cp -a "$PADLOCK_ETC"/* "$backup_dir/" 2>/dev/null || true
    fi
    info "Current environment backed up to: $backup_dir"

    # Import based on mode
    case "$merge_mode" in
        --replace)
            warn "Replacing current padlock environment."
            rm -f "$PADLOCK_ETC/manifest.txt"
            rm -rf "$PADLOCK_KEYS"
            rm -rf "$PADLOCK_ETC/repos"
            mkdir -p "$PADLOCK_KEYS"
            cp "$temp_dir/manifest.txt" "$PADLOCK_ETC/manifest.txt"
            cp -r "$temp_dir/keys"/* "$PADLOCK_KEYS/"
            # Restore repo artifacts if they exist in the import
            if [[ -d "$temp_dir/repos" ]]; then
                cp -r "$temp_dir/repos" "$PADLOCK_ETC/repos"
            fi
            ;;
        --merge)
            info "Merging with current environment."
            _merge_manifests "$temp_dir/manifest.txt" "$PADLOCK_ETC/manifest.txt"
            cp -rT "$temp_dir/keys" "$PADLOCK_KEYS" 2>/dev/null || true
            # Restore repo artifacts if they exist in the import
            if [[ -d "$temp_dir/repos" ]]; then
                mkdir -p "$PADLOCK_ETC/repos"
                cp -rT "$temp_dir/repos" "$PADLOCK_ETC/repos" 2>/dev/null || true
            fi
            ;;
        *)
            fatal "Unknown import mode: $merge_mode. Use --merge or --replace."
            ;;
    esac

    okay "‚úì Import completed successfully."
}

do_snapshot() {
    local snapshot_name="${1:-auto_$(date +%Y%m%d_%H%M%S)}"
    local snapshots_dir="$PADLOCK_ETC/snapshots"

    mkdir -p "$snapshots_dir"

    # Use a temporary, non-guessable passphrase for the snapshot export
    local snapshot_pass
    snapshot_pass=$(openssl rand -base64 32)

    local export_file="$snapshots_dir/${snapshot_name}.tar.age"

    info "Creating snapshot: $snapshot_name"

    local temp_dir
    temp_dir=$(_temp_mktemp_d)
    trap 'rm -rf "$temp_dir"' RETURN

    cp "$PADLOCK_ETC/manifest.txt" "$temp_dir/manifest.txt"
    cp -r "$PADLOCK_KEYS" "$temp_dir/keys"
    
    # Include repo artifacts in snapshot
    if [[ -d "$PADLOCK_ETC/repos" ]]; then
        cp -r "$PADLOCK_ETC/repos" "$temp_dir/repos"
    fi

    tar -C "$temp_dir" -czf - . | AGE_PASSPHRASE="$snapshot_pass" age -p > "$export_file"
    if [[ $? -ne 0 ]]; then
        fatal "Failed to create snapshot export file."
    fi

    # Create snapshot metadata, including the passphrase
    cat > "$snapshots_dir/${snapshot_name}.info" << EOF
name=$snapshot_name
created=$(date -Iseconds)
passphrase=$snapshot_pass
repos=$(grep -cv "^#" "$PADLOCK_ETC/manifest.txt")
keys=$(find "$PADLOCK_KEYS" -name "*.key" | wc -l)
EOF

    okay "‚úì Snapshot created: $snapshot_name"
}

do_rewind() {
    local snapshot_name="$1"
    local snapshots_dir="$PADLOCK_ETC/snapshots"

    if [[ ! -f "$snapshots_dir/${snapshot_name}.tar.age" || ! -f "$snapshots_dir/${snapshot_name}.info" ]]; then
        error "Snapshot not found: $snapshot_name"
        info "Available snapshots:"
        ls -1 "$snapshots_dir"/*.info 2>/dev/null | sed 's/\.info$//' | xargs -I {} basename {} || echo " (none)"
        return 1
    fi

    warn "This will ERASE your current padlock environment and restore the snapshot."
    read -p "Type the snapshot name to confirm: '$snapshot_name': " confirm
    if [[ "$confirm" != "$snapshot_name" ]]; then
        info "Rewind cancelled."
        return 0
    fi

    # Get the passphrase from the metadata file
    local snapshot_pass
    snapshot_pass=$(grep "^passphrase=" "$snapshots_dir/${snapshot_name}.info" | cut -d'=' -f2)

    # Call do_import with the correct arguments for non-interactive restore
    do_import "$snapshots_dir/${snapshot_name}.tar.age" --replace "$snapshot_pass"

    okay "‚úì Rewound to snapshot: $snapshot_name"
}

do_install() {
    local force="$opt_force"
    
    # Parse command-specific arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                force=1
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    _logo
    # Check if already installed
    local install_dir="$XDG_LIB_HOME/fx/lib"
    local link_path="$XDG_BIN_HOME/fx/padlock"
    local lib_file="$install_dir/padlock.sh"
    
    if [[ -f "$lib_file" ]] && [[ "$force" -eq 0 ]]; then
        warn "Padlock already installed (use --force to reinstall)"
        return 0
    fi
    
    info "Installing padlock to system..."
    
    # Remove old installation if exists
    if [[ -f "$lib_file" ]]; then
        info "Removing existing installation..."
        rm -f "$lib_file"
    fi
    if [[ -L "$link_path" ]]; then
        rm -f "$link_path"
    fi
    
    # Create installation directories
    mkdir -p "$install_dir" "$(dirname "$link_path")"
    
    # Copy only the built padlock.sh script to lib directory
    cp "$SCRIPT_PATH" "$lib_file"
    chmod +x "$lib_file"
    
    # Create symlink to bin directory
    ln -sf "$lib_file" "$link_path"
    
    # Generate master key on first install
    _ensure_master_key
    
    okay "‚úì Padlock installed to: $lib_file"
    info "Available as: $link_path"
    info "üóùÔ∏è  Global master key configured"
}

do_uninstall() {
    local lib_file="$XDG_LIB_HOME/fx/lib/padlock.sh"
    local link_path="$XDG_BIN_HOME/fx/padlock"
    
    info "üóëÔ∏è  Uninstalling padlock from system..."
    
    if [[ -L "$link_path" ]]; then
        rm "$link_path"
        info "‚úì Removed symlink: $link_path"
    fi
    
    if [[ -f "$lib_file" ]]; then
        rm "$lib_file"
        info "‚úì Removed library: $lib_file"
    fi
    
    if [[ ! -L "$link_path" ]] && [[ ! -f "$lib_file" ]]; then
        warn "‚ö†Ô∏è  Padlock was not installed or already removed"
        return 0
    fi
    
    okay "‚úì Padlock uninstalled successfully"
    info "üí° Keys and repositories remain in ~/.local/etc/padlock/"
}

_overdrive_unlock() {
    REPO_ROOT=$(_get_repo_root .)

    if [[ ! -f "$REPO_ROOT/super_chest.age" ]]; then
        error "Repository not in overdrive mode"
        return 1
    fi

    lock "üîì Disengaging overdrive mode..."

    if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
        error "Master key not found, cannot unlock overdrive mode."
        info "Ensure your master key is available at $PADLOCK_GLOBAL_KEY"
        return 1
    fi
    export PADLOCK_KEY_FILE="$PADLOCK_GLOBAL_KEY"

    local super_chest="$REPO_ROOT/.super_chest"
    mkdir -p "$super_chest"
    
    if ! __decrypt_stream < "$REPO_ROOT/super_chest.age" | tar -C "$super_chest" -xzf -; then
        fatal "Failed to decrypt super_chest.age"
    fi

    if [[ -f "$REPO_ROOT/.overdrive" ]]; then
        local expected_checksum
        expected_checksum=$(grep "Super checksum:" "$REPO_ROOT/.overdrive" | cut -d' ' -f4)
        local current_checksum
        current_checksum=$(_calculate_locker_checksum "$super_chest")

        if [[ "$current_checksum" != "$expected_checksum" ]]; then
            warn "‚ö†Ô∏è  Super chest integrity check failed!"
        else
            trace "‚úì Super chest integrity verified"
        fi
    fi

    cp -rT "$super_chest/" "$REPO_ROOT/"

    rm -rf "$super_chest"
    rm -f "$REPO_ROOT/super_chest.age"
    rm -f "$REPO_ROOT/.overdrive"

    okay "üîì Overdrive disengaged! Repository restored."
}

_overdrive_status() {
    REPO_ROOT=$(_get_repo_root .)

    info "=== Overdrive Status ==="

    if [[ -f "$REPO_ROOT/super_chest.age" ]]; then
        local size
        size=$(du -h "$REPO_ROOT/super_chest.age" 2>/dev/null | cut -f1)
        warn "üöÄ OVERDRIVE ENGAGED"
        info "Blob: super_chest.age ($size)"
        info "To restore: source .overdrive"
    else
        okay "‚úÖ NORMAL MODE"
        info "To engage: padlock overdrive lock"
    fi
}

_overdrive_lock() {
    REPO_ROOT=$(_get_repo_root .)

    if [[ -f "$REPO_ROOT/super_chest.age" ]]; then
        error "Repository already in overdrive mode"
        return 1
    fi

    if [[ ! -d "$REPO_ROOT/locker" ]]; then
        fatal "Locker must be unlocked to engage overdrive mode."
    fi

    lock "üöÄ Engaging overdrive mode..."

    # Create super_chest directory for staging
    local super_chest="$REPO_ROOT/.super_chest"
    mkdir -p "$super_chest"

    # Note: cleanup handled explicitly at end of function

    # Use tar to copy files, which is more reliable than rsync for this case
    info "Archiving entire repository..."
    tar -c --exclude-from <(printf "%s\n" \
        ".super_chest" \
        "bin" \
        ".chest" \
        "super_chest.age" \
        ".locked" \
        ".ignition.key" \
        ".git" \
        ".gitsim" \
        ".locker_checksum" \
        "locker.age" \
    ) -C "$REPO_ROOT" . | tar -x -C "$super_chest"

    source "$REPO_ROOT/locker/.padlock"

    local super_checksum
    super_checksum=$(_calculate_locker_checksum "$super_chest")

    tar --sort=name --mtime='@0' --owner=0 --group=0 --numeric-owner \
        -C "$super_chest" -czf - . | __encrypt_stream > "$REPO_ROOT/super_chest.age"

    # Remove everything except padlock infrastructure and super_chest.age
    find "$REPO_ROOT" -maxdepth 1 -mindepth 1 \
        ! -name ".super_chest" \
        ! -name "bin" \
        ! -name ".chest" \
        ! -name ".git" \
        ! -name ".gitsim" \
        ! -name "super_chest.age" \
        -exec rm -rf {} +

    __print_overdrive_file "$REPO_ROOT/.overdrive" "$super_checksum"

    local size
    size=$(du -h "$REPO_ROOT/super_chest.age" | cut -f1)
    okay "üöÄ Overdrive engaged! Entire repo ‚Üí super_chest.age ($size)"
    
    # Clean up staging directory
    rm -rf "$super_chest"
}

do_overdrive() {
    local action="${1:-lock}"

    case "$action" in
        lock) _overdrive_lock ;;
        unlock)
            _overdrive_unlock
            ;;
        status)
            _overdrive_status
            ;;
        *)
            error "Unknown overdrive action: $action"
            info "Usage: padlock overdrive {lock|unlock|status}"
            return 1
            ;;
    esac
}

# Setup command - alias for clamp with common defaults
do_setup() {
    local target_path="${1:-.}"
    
    info "üîß Setting up padlock in current repository..."
    
    # Default to generating a new key for setup
    do_clamp "$target_path" --generate
}

# Key management commands
do_key() {
    local action="${1:-}"
    shift || true
    
    case "$action" in
        --set-global)
            local key_file="$1"
            if [[ ! -f "$key_file" ]]; then
                fatal "Key file not found: $key_file"
            fi
            
            info "üîë Setting global master key..."
            mkdir -p "$(dirname "$PADLOCK_GLOBAL_KEY")"
            cp "$key_file" "$PADLOCK_GLOBAL_KEY"
            chmod 600 "$PADLOCK_GLOBAL_KEY"
            okay "‚úì Global master key set"
            ;;
        --show-global)
            if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
                error "No global master key found"
                info "Run: padlock key --generate-global"
                return 1
            fi
            
            local public_key
            public_key=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null)
            echo "$public_key"
            ;;
        --generate-global)
            _logo
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]] && [[ "${2:-}" != "--force" ]]; then
                error "Global master key already exists"
                info "Use --force to overwrite"
                return 1
            fi
            
            _ensure_master_key
            okay "‚úì Global master key generated"
            ;;
        --add-recipient)
            local recipient="$1"
            if [[ -z "$recipient" ]]; then
                fatal "--add-recipient requires a public key"
            fi
            
            # Check if we're in a repo with locker config
            if [[ ! -f "locker/.padlock" ]]; then
                error "Not in an unlocked padlock repository"
                info "Run 'padlock unlock' first"
                return 1
            fi
            
            # Load current config
            source "locker/.padlock"
            
            # Add recipient to existing list
            if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
                export AGE_RECIPIENTS="$AGE_RECIPIENTS,$recipient"
            else
                export AGE_RECIPIENTS="$recipient"
            fi
            
            # Update config file
            __print_padlock_config "locker/.padlock" "$(basename "$PWD")"
            
            okay "‚úì Added recipient: ${recipient:0:20}..."
            info "Re-encrypt with: padlock lock"
            ;;
        restore)
            _logo
            _restore_master_key
            ;;
        
        # New key testing commands
        is)
            # padlock key is <type> --key=/path
            local key_type="$1"
            local key_path=""
            shift || true
            
            # Parse options with BashFX pattern
            local opts=("$@")
            for ((i=0; i<${#opts[@]}; i++)); do
                case "${opts[i]}" in
                    --key=*)
                        key_path="${opts[i]#*=}"
                        ;;
                    --path=*)
                        key_path="${opts[i]#*=}"
                        ;;
                esac
            done
            
            if [[ -z "$key_path" ]]; then
                error "Missing --key or --path parameter"
                info "Usage: padlock key is <type> --key=/path/to/key"
                return 1
            fi
            
            # Stub implementation
            info "[STUB] Testing if key at '$key_path' is type '$key_type'"
            info "This feature will analyze key metadata and structure"
            return 0
            ;;
            
        authority)
            # padlock key authority --key1=/path --key2=/path
            local key1="" key2=""
            local opts=("$@")
            
            for ((i=0; i<${#opts[@]}; i++)); do
                case "${opts[i]}" in
                    --key1=*)
                        key1="${opts[i]#*=}"
                        ;;
                    --key2=*)
                        key2="${opts[i]#*=}"
                        ;;
                esac
            done
            
            if [[ -z "$key1" ]] || [[ -z "$key2" ]]; then
                error "Missing required parameters"
                info "Usage: padlock key authority --key1=/path --key2=/path"
                return 1
            fi
            
            # Stub implementation
            info "[STUB] Testing if '$key1' has authority over '$key2'"
            info "This will verify key hierarchy relationships"
            return 0
            ;;
            
        subject)
            # padlock key subject --key1=/path --key2=/path
            local key1="" key2=""
            local opts=("$@")
            
            for ((i=0; i<${#opts[@]}; i++)); do
                case "${opts[i]}" in
                    --key1=*)
                        key1="${opts[i]#*=}"
                        ;;
                    --key2=*)
                        key2="${opts[i]#*=}"
                        ;;
                esac
            done
            
            if [[ -z "$key1" ]] || [[ -z "$key2" ]]; then
                error "Missing required parameters"
                info "Usage: padlock key subject --key1=/path --key2=/path"
                return 1
            fi
            
            # Stub implementation
            info "[STUB] Testing if '$key1' is subject to '$key2'"
            info "This will verify child-parent key relationships"
            return 0
            ;;
            
        type)
            # padlock key type --key=/path
            local key_path=""
            local opts=("$@")
            
            for ((i=0; i<${#opts[@]}; i++)); do
                case "${opts[i]}" in
                    --key=*)
                        key_path="${opts[i]#*=}"
                        ;;
                    --path=*)
                        key_path="${opts[i]#*=}"
                        ;;
                esac
            done
            
            if [[ -z "$key_path" ]]; then
                error "Missing --key parameter"
                info "Usage: padlock key type --key=/path/to/key"
                return 1
            fi
            
            # Stub implementation
            info "[STUB] Identifying key type for: $key_path"
            info "Will return: skull|master|repo|ignition|distro|unknown"
            echo "unknown"  # Placeholder return
            return 0
            ;;
            
        ""|*)
            if [[ -z "$action" ]]; then
                info "Available key management actions:"
            else
                error "Unknown key action: $action"
            fi
            info "  --set-global <key>        Set global master key"
            info "  --show-global             Display global public key"
            info "  --generate-global         Generate new global key"
            info "  --add-recipient <key>     Add recipient to current repo"
            info "  restore                   Restore master key from skull backup"
            info ""
            info "Key Testing Commands:"
            info "  is <type> --key=/path     Test if key is specific type"
            info "  authority --key1=X --key2=Y  Test authority relationship"
            info "  subject --key1=X --key2=Y    Test subject relationship"
            info "  type --key=/path          Identify key type"
            [[ -n "$action" ]] && return 1 || return 0
            ;;
    esac
}

do_master() {
    local action="$1"
    shift || true
    
    case "$action" in
        generate)
            # padlock master generate
            _logo
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]] && [[ "$1" != "--force" ]]; then
                error "Global master key already exists"
                info "Use --force to overwrite"
                return 1
            fi
            
            _ensure_master_key
            okay "‚úì Master key generated"
            ;;
            
        show)
            # padlock master show
            if [[ ! -f "$PADLOCK_GLOBAL_KEY" ]]; then
                error "No global master key found"
                info "Run: padlock master generate"
                return 1
            fi
            
            local public_key
            public_key=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null)
            echo "$public_key"
            ;;
            
        restore)
            # padlock master restore
            _logo
            _restore_master_key
            ;;
            
        unlock)
            # padlock master unlock (same as master-unlock)
            do_master_unlock "$@"
            ;;
            
        help|*)
            if [[ "$action" != "help" ]]; then
                error "Unknown master action: $action"
            fi
            info "Master Key Management Commands:"
            info "  generate [--force]   Generate new global master key"
            info "  show                 Display master public key"
            info "  restore              Restore master key from skull backup"
            info "  unlock               Emergency unlock using master key"
            return 0
            ;;
    esac
}

do_sec() {
    local action="${1:-}"
    
    case "$action" in
        auto)
            # padlock sec auto (was: automap)
            shift || true
            do_automap "$@"
            ;;
            
        add)
            # padlock sec add /path
            shift || true
            local path="${1:-}"
            if [[ -z "$path" ]]; then
                error "Missing file path"
                info "Usage: padlock sec add <path>"
                return 1
            fi
            
            do_map add "$path" "${@:2}"
            ;;
            
        "")
            # padlock sec (no action) - show help
            info "File Security Commands:"
            info "  <path>              Secure file (default: add)"
            info "  add <path>          Add file to security mapping"
            info "  remove <path>       Remove file from security mapping"
            info "  auto                Auto-secure sensitive files (*.md, build.sh, etc.)"
            return 0
            ;;
            
        *)
            # padlock sec /path (treat first arg as path)
            if [[ -z "$action" ]]; then
                error "Missing file path"
                info "Usage: padlock sec <path>"
                return 1
            fi
            
            do_map add "$action" "${@:2}"
            ;;
            
        remove)
            # padlock sec remove /path
            local path="$1"
            if [[ -z "$path" ]]; then
                error "Missing file path"
                info "Usage: padlock sec remove <path>"
                return 1
            fi
            
            do_map remove "$path" "${@:2}"
            ;;
            
        help|*)
            if [[ "$action" != "help" ]] && [[ "$action" != "auto" ]] && [[ -n "$action" ]]; then
                # Treat as path for backward compatibility
                do_map add "$action" "$@"
                return
            fi
            
            if [[ "$action" != "help" ]] && [[ "$action" != "auto" ]]; then
                error "Unknown sec action: $action"
            fi
            info "File Security Commands:"
            info "  <path>              Secure file (default: add)"
            info "  add <path>          Add file to security mapping"
            info "  remove <path>       Remove file from security mapping"
            info "  auto                Auto-secure sensitive files (*.md, build.sh, etc.)"
            return 0
            ;;
    esac
}

do_setup() {
    local subcommand="${1:-}"
    
    case "$subcommand" in
        ignition)
            # Direct skull backup creation
            _create_skull_backup
            return $?
            ;;
        *)
            # Default interactive setup
            _logo
            info "üîß Padlock Interactive Setup"
            echo
            
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                okay "‚úì Master key already exists"
                
                # Check if skull backup exists
                local skull_backup="$PADLOCK_KEYS/skull.age"
                if [[ -f "$skull_backup" ]]; then
                    okay "‚úì Skull backup exists"
                    info "Your padlock is fully configured."
                    echo
                    info "Available commands:"
                    info "  padlock clamp <dir>       - Deploy to a new repository"
                    info "  padlock setup skull       - Recreate skull backup"
                    info "  padlock key restore       - Restore from skull backup"
                    info "  padlock --help            - Show all commands"
                    return 0
                else
                    warn "‚ö†Ô∏è  Skull backup is missing"
                    info "Creating skull backup from existing master key..."
                    echo
                    _create_skull_backup
                    return $?
                fi
            fi
            ;;
    esac
    
    echo "This will set up padlock encryption with a master key and skull backup."
    echo "The skull backup allows you to recover your master key if lost."
    echo
    read -p "Proceed with setup? [Y/n]: " confirm
    if [[ "$confirm" =~ ^[nN]$ ]]; then
        info "Setup cancelled."
        return 1
    fi
    
    echo
    info "üîë Creating master key and skull backup..."
    _ensure_master_key
    
    echo
    okay "‚úì Setup complete!"
    echo
    info "Next steps:"
    info "  1. Run 'padlock clamp <directory>' to secure a repository"
    info "  2. Keep your master key safe: $PADLOCK_GLOBAL_KEY"
    info "  3. Remember your ignition passphrase for emergency recovery"
}

do_repair() {
    local repo_path="${1:-.}"
    repo_path="$(realpath "$repo_path")"
    
    info "üîß Padlock Repair Tool"
    echo
    
    # Check if this looks like a padlock repository - show help if not
    if [[ ! -f "$repo_path/bin/padlock" ]]; then
        info "No padlock installation found in: $repo_path"
        info "The 'repair' command fixes existing padlock repositories"
        info ""
        info "Usage: padlock repair [path]"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Repository must have padlock already deployed"
        info "  ‚Ä¢ Use 'padlock clamp' to set up a new repository first"
        return 0
    fi
    
    # Check what's missing and what can be repaired
    local missing_items=()
    local can_repair=false
    local was_locked=false
    
    if [[ ! -f "$repo_path/locker/.padlock" ]]; then
        if [[ -d "$repo_path/locker" ]]; then
            # Repository is unlocked but .padlock is missing
            missing_items+=(".padlock config file")
            can_repair=true
        else
            # Repository appears to be locked, check if encrypted data exists
            if [[ -f "$repo_path/.chest/locker.age" ]] || [[ -f "$repo_path/locker.age" ]]; then
                info "Repository is currently locked. Unlocking first..."
                if cd "$repo_path" && ./bin/padlock unlock; then
                    was_locked=true
                    can_repair=true
                    missing_items+=(".padlock config file")
                else
                    error "Cannot unlock repository. Repair cannot proceed."
                    info "Ensure you have the correct master key or try 'padlock key restore'"
                    return 1
                fi
            else
                # No encrypted data found and no locker directory
                info "No encrypted locker found (locker.age or .chest/locker.age missing)"
                info "The 'repair' command expects to find encrypted locker data"
                info ""
                info "Usage: padlock repair [path]"
                info ""
                info "Prerequisites:"
                info "  ‚Ä¢ Repository should have a locker.age file (old format) or .chest/locker.age (new format)"
                info "  ‚Ä¢ Use 'padlock clamp' first if this is a new setup"
                return 0
            fi
        fi
    fi
    
    if [[ ${#missing_items[@]} -eq 0 ]]; then
        okay "‚úì No missing artifacts detected"
        info "Repository appears to be in good condition."
        return 0
    fi
    
    # Look up repository in manifest for repair information
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    local manifest_entry=""
    
    if [[ -f "$manifest_file" ]]; then
        manifest_entry=$(grep "|$repo_path|" "$manifest_file" 2>/dev/null || true)
    fi
    
    if [[ -z "$manifest_entry" ]]; then
        warn "‚ö†Ô∏è  Repository not found in global manifest"
        info "Attempting repair from available evidence..."
    else
        info "üìã Found manifest entry for this repository"
        trace "Manifest: $manifest_entry"
    fi
    
    # Repair missing .padlock file
    if printf '%s\n' "${missing_items[@]}" | grep -q ".padlock config file"; then
        info "üîß Repairing .padlock configuration..."
        
        # Determine repository type and key configuration
        local repo_type="standard"
        local key_file=""
        local recipients=""
        
        if [[ -n "$manifest_entry" ]]; then
            repo_type=$(echo "$manifest_entry" | cut -d'|' -f4)
        fi
        
        # Try to determine key configuration from existing setup
        if [[ "$repo_type" == "ignition" ]]; then
            # For ignition mode, we need to check if chest exists
            if [[ -d "$repo_path/.chest" && -f "$repo_path/.chest/ignition.age" ]]; then
                info "üî• Detected ignition mode setup"
                # This would require ignition key to decrypt, for now set up for master key access
                key_file="$PADLOCK_GLOBAL_KEY"
                recipients=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null || echo "")
            else
                warn "Ignition setup incomplete, falling back to standard mode"
                repo_type="standard"
            fi
        fi
        
        if [[ "$repo_type" == "standard" ]]; then
            # Try to find repository-specific key
            local repo_name
            repo_name=$(basename "$repo_path")
            local repo_key="$PADLOCK_KEYS/$repo_name.key"
            
            if [[ -f "$repo_key" ]]; then
                key_file="$repo_key"
                recipients=$(age-keygen -y "$repo_key" 2>/dev/null || echo "")
                info "üîë Using repository-specific key"
            elif [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                key_file="$PADLOCK_GLOBAL_KEY"
                recipients=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null || echo "")
                info "üîë Using global master key"
            else
                error "No suitable key found for repair"
                info "Options:"
                info "  ‚Ä¢ Run 'padlock key --generate-global' to create master key"
                info "  ‚Ä¢ Run 'padlock key restore' if you have skull backup"
                return 1
            fi
        fi
        
        if [[ -n "$recipients" ]]; then
            # Set up environment for config generation
            export AGE_RECIPIENTS="$recipients"
            export PADLOCK_KEY_FILE="$key_file"
            export AGE_PASSPHRASE=""
            export REPO_ROOT="$repo_path"
            
            # Generate new .padlock config
            __print_padlock_config "$repo_path/locker/.padlock" "$(basename "$repo_path")"
            
            okay "‚úì Regenerated .padlock configuration"
            info "Key: $(basename "$key_file")"
            info "Recipient: ${recipients:0:20}..."
        else
            error "Failed to determine encryption configuration"
            return 1
        fi
    fi
    
    # Try to restore any missing artifacts
    if _restore_repo_artifacts "$repo_path"; then
        info "üîß Additional artifacts restored from backup"
    else
        # Check if artifacts exist in local namespace (migration scenario)
        local repo_name=$(basename "$repo_path")
        local namespace="local"
        if [[ -d "$repo_path/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
            if [[ -n "$remote_url" ]]; then
                # Parse remote URL to determine current namespace
                local host user_repo
                if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
                    host="${BASH_REMATCH[1]}"
                    user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
                elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
                    host="${BASH_REMATCH[1]}"
                    user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
                else
                    host="unknown"
                    user_repo=$(basename "$repo_path")
                fi
                namespace="$host"
                repo_name="$user_repo"
            fi
        fi
        
        # If current namespace is not 'local', check for orphaned local artifacts
        if [[ "$namespace" != "local" ]]; then
            local local_artifacts_dir="$PADLOCK_ETC/repos/local/$(basename "$repo_path")"
            local current_artifacts_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
            if [[ -d "$local_artifacts_dir" && ! -d "$current_artifacts_dir" ]]; then
                info "üö® Found orphaned artifacts in local namespace"
                info "Migrating from local to current namespace..."
                if _migrate_artifacts_namespace "$local_artifacts_dir" "$current_artifacts_dir"; then
                    okay "‚úì Migrated orphaned artifacts"
                    rm -rf "$local_artifacts_dir"
                    _restore_repo_artifacts "$repo_path"  # Try restore again
                fi
            fi
        fi
    fi
    
    echo
    okay "‚úì Repair completed successfully"
    info "Repository should now be functional."
    info "Test with: padlock status"
}

# Safe declamp operation - remove padlock infrastructure while preserving data
do_declamp() {
    local repo_path="${1:-.}"
    local force="${2:-}"
    
    repo_path="$(realpath "$repo_path")"
    
    # Validate target - show help if not a git repository
    if ! is_git_repo "$repo_path"; then
        info "Target is not a git repository: $repo_path"
        info "The 'declamp' command removes padlock encryption from a git repository"
        info ""
        info "Usage: padlock declamp [path] [--force]"
        info ""
        info "Options:"
        info "  --force    Force removal even if repository is locked"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Target directory must be a git repository with padlock deployed"
        info "  ‚Ä¢ Repository should be unlocked (or use --force)"
        return 0
    fi
    
    REPO_ROOT="$(_get_repo_root "$repo_path")"
    
    # Check if padlock is deployed - show help if not
    if ! is_deployed "$REPO_ROOT"; then
        info "Padlock not deployed in this repository"
        info "The 'declamp' command removes padlock encryption from a repository"
        info ""
        info "Usage: padlock declamp [path] [--force]"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Repository must have padlock already deployed (see 'padlock clamp')"
        info "  ‚Ä¢ Nothing to declamp from this repository"
        return 0
    fi
    
    lock "üîì Safely declamping padlock from repository..."
    
    # Ensure repository is unlocked first
    local state="$(_get_lock_state "$REPO_ROOT")"
    if [[ "$state" == "locked" ]]; then
        if [[ "$force" != "--force" ]]; then
            error "Repository is locked. Unlock first or use --force"
            info "To unlock: padlock unlock"
            info "Or force: padlock declamp --force"
            return 1
        fi
        
        # Force unlock before declamp
        warn "Force-unlocking locked repository..."
        if [[ -f "$REPO_ROOT/locker.age" ]]; then
            info "Unlocking standard locker..."
            if ! (cd "$REPO_ROOT" && "$REPO_ROOT/bin/padlock" unlock); then
                fatal "Failed to unlock repository for declamp"
            fi
        elif [[ -f "$REPO_ROOT/.chest/locker.age" ]]; then
            info "Unlocking chest mode..."
            if ! (cd "$REPO_ROOT" && "$REPO_ROOT/bin/padlock" unlock); then
                fatal "Failed to unlock repository for declamp"
            fi
        fi
    fi
    
    # Show what will be preserved
    if [[ -d "$REPO_ROOT/locker" ]]; then
        local file_count
        file_count=$(find "$REPO_ROOT/locker" -type f | wc -l)
        info "üìÅ Preserving $file_count files from locker/ (will remain as plaintext)"
    else
        warn "No locker directory found - nothing to preserve"
    fi
    
    # Show what will be removed
    local items_to_remove=()
    [[ -d "$REPO_ROOT/bin" ]] && items_to_remove+=("bin/")
    [[ -d "$REPO_ROOT/.githooks" ]] && items_to_remove+=(".githooks/")
    [[ -f "$REPO_ROOT/locker.age" ]] && items_to_remove+=("locker.age")
    [[ -f "$REPO_ROOT/.locked" ]] && items_to_remove+=(".locked")
    [[ -d "$REPO_ROOT/.chest" ]] && items_to_remove+=(".chest/")
    [[ -f "$REPO_ROOT/padlock.map" ]] && items_to_remove+=("padlock.map")
    [[ -f "$REPO_ROOT/.locker_checksum" ]] && items_to_remove+=(".locker_checksum")
    [[ -f "$REPO_ROOT/SECURITY.md" ]] && items_to_remove+=("SECURITY.md")
    
    if [[ ${#items_to_remove[@]} -gt 0 ]]; then
        info "üóëÔ∏è  Will remove: ${items_to_remove[*]}"
    fi
    
    # Confirm destructive operation
    if [[ "$force" != "--force" ]]; then
        echo
        warn "‚ö†Ô∏è  This will permanently remove padlock infrastructure"
        read -p "Continue? (y/N): " -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            info "Declamp cancelled"
            return 0
        fi
    fi
    
    # Remove padlock infrastructure
    local removed_items=()
    
    # Remove bin directory
    if [[ -d "$REPO_ROOT/bin" ]]; then
        rm -rf "$REPO_ROOT/bin"
        removed_items+=("bin/")
    fi
    
    # Remove git hooks
    if [[ -d "$REPO_ROOT/.githooks" ]]; then
        rm -rf "$REPO_ROOT/.githooks"
        removed_items+=(".githooks/")
    fi
    
    # Remove encrypted artifacts
    if [[ -f "$REPO_ROOT/locker.age" ]]; then
        rm -f "$REPO_ROOT/locker.age"
        removed_items+=("locker.age")
    fi
    
    if [[ -f "$REPO_ROOT/.locked" ]]; then
        rm -f "$REPO_ROOT/.locked"
        removed_items+=(".locked")
    fi
    
    if [[ -d "$REPO_ROOT/.chest" ]]; then
        rm -rf "$REPO_ROOT/.chest"
        removed_items+=(".chest/")
    fi
    
    # Remove padlock.map and checksums
    if [[ -f "$REPO_ROOT/padlock.map" ]]; then
        rm -f "$REPO_ROOT/padlock.map"
        removed_items+=("padlock.map")
    fi
    
    if [[ -f "$REPO_ROOT/.locker_checksum" ]]; then
        rm -f "$REPO_ROOT/.locker_checksum"
        removed_items+=(".locker_checksum")
    fi
    
    # Remove other padlock files
    rm -f "$REPO_ROOT/.overdrive"
    rm -f "$REPO_ROOT/super_chest.age"
    
    # Clean up .gitattributes (remove padlock lines)
    if [[ -f "$REPO_ROOT/.gitattributes" ]]; then
        local temp_attrs
        temp_attrs=$(mktemp)
        grep -v "locker.age\|filter=locker-crypt\|bin/\*\|.githooks/\*" "$REPO_ROOT/.gitattributes" > "$temp_attrs" || true
        mv "$temp_attrs" "$REPO_ROOT/.gitattributes"
        
        # Remove file if empty (except comments and whitespace)
        if ! grep -q "^[^#[:space:]]" "$REPO_ROOT/.gitattributes" 2>/dev/null; then
            rm -f "$REPO_ROOT/.gitattributes"
            removed_items+=(".gitattributes")
        fi
    fi
    
    # Clean up .gitignore (remove padlock lines)
    if [[ -f "$REPO_ROOT/.gitignore" ]]; then
        local temp_ignore
        temp_ignore=$(mktemp)
        grep -v "^locker/$\|^# Padlock" "$REPO_ROOT/.gitignore" > "$temp_ignore" || true
        mv "$temp_ignore" "$REPO_ROOT/.gitignore"
    fi
    
    # Remove git configuration
    (cd "$REPO_ROOT" && {
        git config --unset filter.locker-crypt.clean 2>/dev/null || true
        git config --unset filter.locker-crypt.smudge 2>/dev/null || true
        git config --unset filter.locker-crypt.required 2>/dev/null || true
        git config --unset core.hooksPath 2>/dev/null || true
    })
    
    # Remove from global manifest
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        grep -v -F "$REPO_ROOT" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        trace "Removed from global manifest"
    fi
    
    # Remove repository-specific keys and namespace artifacts
    local repo_name="$(basename "$REPO_ROOT")"
    local repo_key_file="$PADLOCK_KEYS/$repo_name.key"
    
    # Determine namespace to find artifacts
    local namespace="local"
    if [[ -d "$REPO_ROOT/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$REPO_ROOT" remote get-url origin 2>/dev/null || echo "")
        if [[ "$remote_url" =~ github\.com[:/]([^/]+)/(.+) ]]; then
            namespace="github.com"
        elif [[ "$remote_url" =~ gitlab\.com[:/]([^/]+)/(.+) ]]; then
            namespace="gitlab.com"
        elif [[ "$remote_url" =~ ([^/:]+)[:/]([^/]+)/(.+) ]]; then
            namespace="${BASH_REMATCH[1]}"
        fi
    fi
    
    # Remove repository key
    if [[ -f "$repo_key_file" ]]; then
        rm -f "$repo_key_file"
        trace "Removed repository key: $repo_key_file"
    fi
    
    # Remove namespace artifacts directory
    local artifacts_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
    if [[ -d "$artifacts_dir" ]]; then
        rm -rf "$artifacts_dir"
        trace "Removed artifacts directory: $artifacts_dir"
        
        # Clean up empty parent directories
        local namespace_dir="$PADLOCK_ETC/repos/$namespace"
        if [[ -d "$namespace_dir" ]] && [[ -z "$(ls -A "$namespace_dir" 2>/dev/null)" ]]; then
            rmdir "$namespace_dir"
            trace "Removed empty namespace directory: $namespace_dir"
        fi
    fi
    
    # Remove template SECURITY.md if it's the padlock one
    if [[ -f "$REPO_ROOT/SECURITY.md" ]] && grep -q "Padlock" "$REPO_ROOT/SECURITY.md" 2>/dev/null; then
        rm -f "$REPO_ROOT/SECURITY.md"
        removed_items+=("SECURITY.md")
    fi
    
    # Success message
    okay "‚úì Padlock safely removed from repository"
    
    if [[ -d "$REPO_ROOT/locker" ]]; then
        local preserved_count
        preserved_count=$(find "$REPO_ROOT/locker" -type f | wc -l)
        okay "‚úÖ Preserved $preserved_count files in locker/ (now unencrypted)"
        warn "‚ö†Ô∏è  locker/ is now unencrypted plaintext"
        info "üí° Add 'locker/' to .gitignore before committing"
    fi
    
    if [[ ${#removed_items[@]} -gt 0 ]]; then
        info "üóëÔ∏è  Removed: ${removed_items[*]}"
    fi
    
    info "üìã Repository restored to standard git repo"
}

# Revocation operations - remove access to encrypted content
do_map() {
    local src_path="${1:-}"
    local action="${2:-add}"
    
    local repo_root="$(_get_repo_root .)"
    local map_file="$repo_root/padlock.map"
    
    if [[ -z "$src_path" ]]; then
        # Show current mappings
        if [[ -f "$map_file" ]]; then
            info "üìã Current file mappings:"
            echo
            while IFS='|' read -r src_rel dest_rel checksum; do
                # Skip comments and empty lines
                [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
                [[ -z "$src_rel" ]] && continue
                
                local src_abs="$repo_root/$src_rel"
                local status="‚ùì"
                local checksum_status=""
                
                if [[ -f "$src_abs" ]]; then
                    status="‚úì"
                    if [[ -n "$checksum" ]]; then
                        local current_checksum
                        current_checksum=$(md5sum "$src_abs" | cut -d' ' -f1)
                        if [[ "$current_checksum" == "$checksum" ]]; then
                            checksum_status="‚úì"
                        else
                            checksum_status="‚ö†Ô∏è"
                        fi
                    fi
                elif [[ -d "$src_abs" ]]; then
                    status="üìÅ"
                    if [[ -n "$checksum" ]]; then
                        local current_checksum
                        current_checksum=$(find "$src_abs" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
                        if [[ "$current_checksum" == "$checksum" ]]; then
                            checksum_status="‚úì"
                        else
                            checksum_status="‚ö†Ô∏è"
                        fi
                    fi
                else
                    status="‚ùå"
                    checksum_status="‚ùå"
                fi
                
                if [[ -n "$checksum" ]]; then
                    printf "  %s %s %s [%s]\n" "$status" "$checksum_status" "$src_rel" "${checksum:0:8}..."
                else
                    printf "  %s %s\n" "$status" "$src_rel"
                fi
            done < "$map_file"
            echo
            info "Usage: padlock map <file|dir> [add|remove]"
        else
            info "No mappings defined. Use: padlock map <file|dir>"
        fi
        return 0
    fi
    
    # Normalize source path
    if [[ "$src_path" = /* ]]; then
        # Absolute path - convert to relative from repo root
        src_path="$(realpath --relative-to="$repo_root" "$src_path")"
    else
        # Relative path - ensure it exists
        src_path="$(realpath --relative-to="$repo_root" "$repo_root/$src_path")"
    fi
    
    # Validate source exists
    local src_abs="$repo_root/$src_path"
    if [[ ! -e "$src_abs" ]]; then
        error "Source not found: $src_path"
        return 1
    fi
    
    # Prevent mapping files already in locker/
    if [[ "$src_path" == locker/* ]]; then
        error "Files in locker/ are automatically included"
        info "Map command is for files outside the locker/"
        return 1
    fi
    
    # Prevent mapping sensitive padlock files
    case "$src_path" in
        .git/*|bin/*|.githooks/*|locker.age|.locked|.chest/*|super_chest.age|.overdrive|padlock.map)
            error "Cannot map padlock infrastructure files"
            return 1
            ;;
    esac
    
    case "$action" in
        add)
            # Create map file if it doesn't exist
            if [[ ! -f "$map_file" ]]; then
                cat > "$map_file" << 'EOF'
# Padlock File Mapping
# Format: source_path|destination_path|md5_checksum
# Paths are relative to repository root
# Files listed here will be included in encrypted chest
EOF
            fi
            
            # Check if already mapped
            if grep -q "^$src_path|" "$map_file" 2>/dev/null; then
                warn "Already mapped: $src_path"
                return 0
            fi
            
            # Calculate checksum
            local checksum=""
            if [[ -f "$src_abs" ]]; then
                checksum=$(md5sum "$src_abs" | cut -d' ' -f1)
            elif [[ -d "$src_abs" ]]; then
                # For directories, create a checksum based on all files
                checksum=$(find "$src_abs" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
            fi
            
            # Add mapping with checksum
            echo "$src_path|$src_path|$checksum" >> "$map_file"
            
            # Backup the updated map file
            _backup_repo_artifacts "$repo_root"
            
            if [[ -f "$src_abs" ]]; then
                okay "‚úì Mapped file: $src_path"
            elif [[ -d "$src_abs" ]]; then
                okay "‚úì Mapped directory: $src_path"
                local file_count
                file_count=$(find "$src_abs" -type f | wc -l)
                info "üìÅ Contains $file_count files"
            fi
            ;;
            
        remove)
            if [[ ! -f "$map_file" ]]; then
                error "No mappings file found"
                return 1
            fi
            
            if ! grep -q "^$src_path|" "$map_file"; then
                error "Not mapped: $src_path"
                return 1
            fi
            
            # Remove the mapping
            local temp_file
            temp_file=$(_temp_mktemp)
            grep -v "^$src_path|" "$map_file" > "$temp_file"
            mv "$temp_file" "$map_file"
            
            # Backup the updated map file
            _backup_repo_artifacts "$repo_root"
            
            okay "‚úì Unmapped: $src_path"
            ;;
            
        *)
            error "Unknown action: $action"
            info "Available actions: add, remove"
            return 1
            ;;
    esac
    
    info "üí° Changes take effect on next lock operation"
}

do_automap() {
    local repo_root="$(_get_repo_root .)"
    local map_file="$repo_root/padlock.map"
    
    info "ü§ñ Auto-detecting files and directories for mapping..."
    
    # Create map file if it doesn't exist
    if [[ ! -f "$map_file" ]]; then
        cat > "$map_file" << 'EOF'
# Padlock File Mapping
# Format: source_path|destination_path|md5_checksum
# Paths are relative to repository root
# Files listed here will be included in encrypted chest
EOF
    fi
    
    local mapped_count=0
    local skipped_count=0
    
    # Auto-detect patterns
    local patterns=(
        # Markdown files (except README and SECURITY, case insensitive)
        "*.md"
        # Build and parts directory
        "build.sh"
        "parts"
        # AI/IDE directories
        ".claude" ".gemini" ".codex" ".priv" ".sec"
        # Local and backup files in root
        "*.local.*" "*bak*"
    )
    
    # Function to check if already mapped
    _is_mapped() {
        local path="$1"
        grep -q "^$path|" "$map_file" 2>/dev/null
    }
    
    # Function to check if file should be excluded
    _should_exclude() {
        local path="$1"
        local basename_lower
        basename_lower=$(basename "$path" | tr '[:upper:]' '[:lower:]')
        
        # Exclude README.md and SECURITY.md (case insensitive)
        case "$basename_lower" in
            readme.md|security.md)
                return 0
                ;;
        esac
        
        # Exclude padlock infrastructure
        case "$path" in
            .git/*|bin/*|.githooks/*|locker.age|.locked|.chest/*|super_chest.age|.overdrive|padlock.map|locker/*)
                return 0
                ;;
        esac
        
        return 1
    }
    
    # Function to add mapping
    _add_automap() {
        local src_path="$1"
        local src_abs="$repo_root/$src_path"
        
        # Skip if already mapped
        if _is_mapped "$src_path"; then
            trace "Already mapped: $src_path"
            ((skipped_count++))
            return 0
        fi
        
        # Skip if should be excluded
        if _should_exclude "$src_path"; then
            trace "Excluded: $src_path"
            ((skipped_count++))
            return 0
        fi
        
        # Calculate checksum
        local checksum=""
        if [[ -f "$src_abs" ]]; then
            checksum=$(md5sum "$src_abs" | cut -d' ' -f1)
        elif [[ -d "$src_abs" ]]; then
            checksum=$(find "$src_abs" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
        fi
        
        # Add mapping
        echo "$src_path|$src_path|$checksum" >> "$map_file"
        ((mapped_count++))
        
        if [[ -f "$src_abs" ]]; then
            okay "‚úì Auto-mapped file: $src_path"
        elif [[ -d "$src_abs" ]]; then
            okay "‚úì Auto-mapped directory: $src_path"
            local file_count
            file_count=$(find "$src_abs" -type f | wc -l)
            trace "  üìÅ Contains $file_count files"
        fi
    }
    
    # Process each pattern
    for pattern in "${patterns[@]}"; do
        case "$pattern" in
            "*.md")
                # Find all .md files in root, exclude README.md and SECURITY.md
                while IFS= read -r -d '' file; do
                    local rel_path
                    rel_path=$(realpath --relative-to="$repo_root" "$file")
                    _add_automap "$rel_path"
                done < <(find "$repo_root" -maxdepth 1 -name "*.md" -type f -print0)
                ;;
            "*.local.*"|"*bak*")
                # Find files matching these patterns in root
                while IFS= read -r -d '' file; do
                    local rel_path
                    rel_path=$(realpath --relative-to="$repo_root" "$file")
                    _add_automap "$rel_path"
                done < <(find "$repo_root" -maxdepth 1 -name "$pattern" -type f -print0)
                ;;
            *)
                # Check if file/directory exists
                if [[ -e "$repo_root/$pattern" ]]; then
                    _add_automap "$pattern"
                fi
                ;;
        esac
    done
    
    # Backup the updated map file
    _backup_repo_artifacts "$repo_root"
    
    # Summary
    echo
    if [[ $mapped_count -gt 0 ]]; then
        okay "üéØ Auto-mapped $mapped_count items"
        if [[ $skipped_count -gt 0 ]]; then
            info "‚è© Skipped $skipped_count items (already mapped or excluded)"
        fi
        info "üí° Changes take effect on next lock operation"
        info "üí° Review mappings with: padlock map"
    else
        info "üìù No new items found to auto-map"
        if [[ $skipped_count -gt 0 ]]; then
            info "‚è© $skipped_count items were skipped (already mapped or excluded)"
        fi
    fi
}

# Unmap files with support for file selection
do_unmap() {
    local target="${1:-}"
    
    local repo_root="$(_get_repo_root .)"
    local map_file="$repo_root/padlock.map"
    
    # Check if repository is locked - show help if so
    if [[ -f ".chest/locker.age" ]] || [[ -f "locker.age" ]]; then
        info "Repository is locked. Unlock first to modify mappings"
        info "The 'unmap' command removes files/directories from mappings"
        info ""
        info "Usage: padlock unmap <file|dir|all>"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Repository must be unlocked to modify mappings"
        info "  ‚Ä¢ Run 'padlock unlock' first"
        return 0
    fi
    
    if [[ ! -f "$map_file" ]]; then
        info "No mappings file found"
        info "The 'unmap' command removes files/directories from mappings"
        info ""
        info "Usage: padlock unmap <file|dir|all>"
        info ""
        info "Prerequisites:"
        info "  ‚Ä¢ Repository must have existing mappings (padlock.map file)"
        info "  ‚Ä¢ Use 'padlock map' to create mappings first"
        return 0
    fi
    
    if [[ -z "$target" ]]; then
        info "Usage: padlock unmap <file|dir|all>"
        info "The 'unmap' command removes files/directories from mappings"
        info ""
        info "Available mappings:"
        do_map
        return 0
    fi
    
    if [[ "$target" == "all" ]]; then
        # Remove all mappings
        local mapping_count
        mapping_count=$(grep -c "^[^#]" "$map_file" 2>/dev/null || echo "0")
        
        if [[ "$mapping_count" -eq 0 ]]; then
            info "No mappings to remove"
            return 0
        fi
        
        echo
        warn "‚ö†Ô∏è  This will remove ALL $mapping_count file mappings"
        read -p "Continue? (y/N): " -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            info "Unmap cancelled"
            return 0
        fi
        
        # Keep only comments and empty lines
        local temp_file
        temp_file=$(_temp_mktemp)
        grep "^#\|^[[:space:]]*$" "$map_file" > "$temp_file" || echo "# Padlock File Mapping" > "$temp_file"
        mv "$temp_file" "$map_file"
        
        okay "‚úì Removed all mappings"
        return 0
    fi
    
    # Normalize target path (convert to relative if absolute)
    if [[ "$target" = /* ]]; then
        target="$(realpath --relative-to="$repo_root" "$target")"
    else
        # Convert relative to canonical form
        if [[ -e "$repo_root/$target" ]]; then
            target="$(realpath --relative-to="$repo_root" "$repo_root/$target")"
        fi
    fi
    
    # Find matching entries
    local matches=()
    while IFS='|' read -r src_rel dest_rel checksum; do
        # Skip comments and empty lines
        [[ "$src_rel" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$src_rel" ]] && continue
        
        # Check for exact match or basename match
        if [[ "$src_rel" == "$target" ]] || [[ "$(basename "$src_rel")" == "$(basename "$target")" ]]; then
            matches+=("$src_rel|$dest_rel|$checksum")
        fi
    done < "$map_file"
    
    if [[ ${#matches[@]} -eq 0 ]]; then
        error "No mapping found for: $target"
        info "Available mappings:"
        padlock map
        return 1
    elif [[ ${#matches[@]} -eq 1 ]]; then
        # Single match - remove it
        local entry="${matches[0]}"
        local src_path="${entry%%|*}"
        
        local temp_file
        temp_file=$(_temp_mktemp)
        grep -v "^$src_path|" "$map_file" > "$temp_file"
        mv "$temp_file" "$map_file"
        
        okay "‚úì Unmapped: $src_path"
    else
        # Multiple matches - let user choose
        info "Multiple mappings found for '$target':"
        echo
        for i in "${!matches[@]}"; do
            local entry="${matches[$i]}"
            local src_path="${entry%%|*}"
            local status="‚ùì"
            
            if [[ -f "$repo_root/$src_path" ]]; then
                status="‚úì"
            elif [[ -d "$repo_root/$src_path" ]]; then
                status="üìÅ"
            else
                status="‚ùå"
            fi
            
            printf "  %d) %s %s\n" $((i + 1)) "$status" "$src_path"
        done
        
        echo
        read -p "Select mapping to remove (1-${#matches[@]}): " -r selection
        
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le ${#matches[@]} ]]; then
            local selected_entry="${matches[$((selection - 1))]}"
            local src_path="${selected_entry%%|*}"
            
            local temp_file
            temp_file=$(_temp_mktemp)
            grep -v "^$src_path|" "$map_file" > "$temp_file"
            mv "$temp_file" "$map_file"
            
            okay "‚úì Unmapped: $src_path"
        else
            error "Invalid selection"
            return 1
        fi
    fi
    
    # Backup the updated map file
    _backup_repo_artifacts "$repo_root"
    
    info "üí° Changes take effect on next lock operation"
}

do_path() {
    local repo_path="${1:-.}"
    repo_path="$(realpath "$repo_path")"
    
    local repo_name=$(basename "$repo_path")
    
    # Determine namespace from git remote or use 'local'
    local namespace="local"
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Parse remote URL to extract host, user, and repo
            local host user_repo
            if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
                # HTTPS: https://github.com/user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
                # SSH: git@github.com:user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            else
                # Fallback for unusual formats
                host="unknown"
                user_repo=$(basename "$repo_path")
            fi
            
            # Create namespace as host, repo as user/repo to avoid collisions
            namespace="$host"
            repo_name="$user_repo"
        fi
    fi
    
    info "üìç Repository path analysis for: $repo_path"
    echo
    
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            info "üîó Git remote: $remote_url"
        else
            info "üîó Git remote: (none - local repository)"
        fi
    else
        info "üîó Git remote: (not a git repository)"
    fi
    
    echo
    info "üìã Computed storage paths:"
    printf "  Namespace: %b%s%b\n" "$cyan" "$namespace" "$xx"
    printf "  Repository: %b%s%b\n" "$cyan" "$repo_name" "$xx"
    echo
    printf "  Key file: %b%s%b\n" "$green" "$PADLOCK_KEYS/$(basename "$repo_path").key" "$xx"
    printf "  Artifacts: %b%s%b\n" "$green" "$PADLOCK_ETC/repos/$namespace/$repo_name/" "$xx"
    echo
    
    # Show what artifacts exist
    local artifacts_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
    local key_file="$PADLOCK_KEYS/$(basename "$repo_path").key"
    
    info "üìÅ Current storage status:"
    if [[ -f "$key_file" ]]; then
        printf "  ‚úì Key file exists: %s\n" "$(basename "$key_file")"
    else
        printf "  ‚úó Key file missing: %s\n" "$(basename "$key_file")"
    fi
    
    if [[ -d "$artifacts_dir" ]]; then
        local artifact_count
        artifact_count=$(find "$artifacts_dir" -type f | wc -l)
        printf "  ‚úì Artifacts backed up: %d files\n" "$artifact_count"
        
        # List specific artifacts
        if [[ -f "$artifacts_dir/.artifact_info" ]]; then
            local backup_date
            backup_date=$(grep "backup_date=" "$artifacts_dir/.artifact_info" 2>/dev/null | cut -d'=' -f2 || echo "unknown")
            printf "  üìÖ Last backup: %s\n" "$backup_date"
        fi
        
        echo "  üìÑ Artifacts:"
        find "$artifacts_dir" -type f -not -name ".artifact_info" | while read -r file; do
            printf "    ‚Ä¢ %s\n" "$(basename "$file")"
        done
    else
        printf "  ‚úó No artifacts backed up\n"
        
        # Check if artifacts exist in the 'local' namespace (migration scenario) - just show info
        if [[ "$namespace" != "local" ]]; then
            local local_artifacts_dir="$PADLOCK_ETC/repos/local/$(basename "$repo_path")"
            if [[ -d "$local_artifacts_dir" ]]; then
                echo
                warn "üö® Migration available!"
                info "Found artifacts in local namespace that can be migrated:"
                printf "  From: %b%s%b\n" "$yellow" "$local_artifacts_dir" "$xx"
                printf "  To:   %b%s%b\n" "$green" "$artifacts_dir" "$xx"
                echo
                printf "  Run: %bpadlock remote%b to update for remote namespace\n" "$green" "$xx"
            fi
        fi
    fi
}

# Helper function to migrate artifacts between namespaces
_migrate_artifacts_namespace() {
    local old_dir="$1"
    local new_dir="$2"
    
    if [[ ! -d "$old_dir" ]]; then
        return 1
    fi
    
    mkdir -p "$new_dir"
    
    # Copy all files except .artifact_info (will be regenerated)
    if find "$old_dir" -type f -not -name ".artifact_info" -exec cp {} "$new_dir/" \; 2>/dev/null; then
        # Update the artifact info with new location
        if [[ -f "$old_dir/.artifact_info" ]]; then
            sed "s|repo_path=.*|repo_path=$(dirname "$new_dir")|" "$old_dir/.artifact_info" > "$new_dir/.artifact_info"
        fi
        return 0
    else
        return 1
    fi
}

do_remote() {
    local repo_path="${1:-.}"
    repo_path="$(realpath "$repo_path")"
    
    info "üîó Padlock Remote Update"
    echo
    
    local repo_name=$(basename "$repo_path")
    local namespace="local"
    local old_artifacts_dir=""
    local new_artifacts_dir=""
    
    # Determine current namespace from git remote
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Parse remote URL to extract host, user, and repo
            local host user_repo
            if [[ "$remote_url" =~ ^https?://([^/]+)/([^/]+)/([^/]+) ]]; then
                # HTTPS: https://github.com/user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            elif [[ "$remote_url" =~ ^[^@]+@([^:]+):([^/]+)/([^/]+) ]]; then
                # SSH: git@github.com:user/repo.git
                host="${BASH_REMATCH[1]}"
                user_repo="${BASH_REMATCH[2]}/${BASH_REMATCH[3]%.git}"
            else
                # Fallback for unusual formats
                host="unknown"
                user_repo=$(basename "$repo_path")
            fi
            
            # Create namespace as host, repo as user/repo
            namespace="$host"
            repo_name="$user_repo"
        fi
    fi
    
    # Check what migrations are available
    old_artifacts_dir="$PADLOCK_ETC/repos/local/$(basename "$repo_path")"
    new_artifacts_dir="$PADLOCK_ETC/repos/$namespace/$repo_name"
    
    # If we're already in the correct namespace, nothing to do
    if [[ "$namespace" == "local" ]]; then
        okay "‚úì Repository has no remote - using local namespace"
        return 0
    fi
    
    # Check if new location already has artifacts
    if [[ -d "$new_artifacts_dir" ]]; then
        okay "‚úì Artifacts already updated for remote namespace"
        info "Current location: $new_artifacts_dir"
        return 0
    fi
    
    # Check if old artifacts exist to update
    if [[ ! -d "$old_artifacts_dir" ]]; then
        warn "‚ö†Ô∏è  No artifacts found in local namespace to update"
        info "Expected old location: $old_artifacts_dir"
        info "Target location: $new_artifacts_dir"
        return 1
    fi
    
    # Show what will be migrated
    if [[ -d "$repo_path/.git" ]]; then
        local remote_url
        remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || echo "")
        info "üîó Git remote: $remote_url"
    fi
    
    echo
    info "üìã Update plan:"
    printf "  From: %b%s%b\n" "$yellow" "$old_artifacts_dir" "$xx"
    printf "  To:   %b%s%b\n" "$green" "$new_artifacts_dir" "$xx"
    
    # Show what artifacts will be moved
    local artifact_count
    artifact_count=$(find "$old_artifacts_dir" -type f -not -name ".artifact_info" | wc -l)
    echo
    info "üìÅ Artifacts to update:"
    find "$old_artifacts_dir" -type f -not -name ".artifact_info" | while read -r file; do
        printf "  ‚Ä¢ %s\n" "$(basename "$file")"
    done
    
    echo
    read -p "Proceed with remote namespace update? [Y/n]: " -r update_response
    if [[ "$update_response" =~ ^[nN]$ ]]; then
        info "Update cancelled"
        return 0
    fi
    
    # Perform the update
    if _migrate_artifacts_namespace "$old_artifacts_dir" "$new_artifacts_dir"; then
        okay "‚úì Artifacts updated successfully"
        rm -rf "$old_artifacts_dir"
        info "Removed old artifacts directory"
        
        echo
        info "üéØ Remote namespace update complete!"
        printf "  New location: %b%s%b\n" "$green" "$new_artifacts_dir" "$xx"
        echo
        info "You can now commit safely. The pre-commit hook will use the correct namespace."
    else
        error "Update failed - old artifacts preserved"
        return 1
    fi
}

do_revoke() {
    local target="${1:-}"
    shift || true
    
    case "$target" in
        ignition)
            # padlock revoke ignition [name]
            local name="${1:-default}"
            info "[STUB] Revoking ignition key: $name"
            info "This will permanently invalidate the ignition key"
            return 0
            ;;
            
        distro)
            # padlock revoke distro [name]
            local name="$1"
            if [[ -z "$name" ]]; then
                error "Missing distro key name"
                info "Usage: padlock revoke distro <name>"
                return 1
            fi
            info "[STUB] Revoking distributed key: $name"
            info "Third-party access with this key will be terminated"
            return 0
            ;;
            
        # Legacy support
        --local)
            _revoke_local_access "$1"
            ;;
        -K|--ignition)
            _revoke_ignition_access "$1"
            ;;
            
        ""|help|*)
            if [[ -z "$target" ]]; then
                info "Available revocation commands:"
            elif [[ "$target" != "help" ]]; then
                error "Unknown revocation target: $target"
            else
                info "Revocation Commands:"
            fi
            info "  ignition [name]     Revoke ignition key (invalidates D keys)"
            info "  distro <name>       Revoke specific distributed key"
            info ""
            info "Legacy:"
            info "  --local             Revoke local access (WARNING: unrecoverable)"
            info "  --ignition          Revoke legacy ignition access"
            [[ -n "$target" ]] && [[ "$target" != "help" ]] && return 1 || return 0
            ;;
    esac
}

# Revoke local access - WARNING: This makes content permanently unrecoverable
_revoke_local_access() {
    local force="$1"
    
    REPO_ROOT="$(_get_repo_root .)"
    
    error "‚ö†Ô∏è  DESTRUCTIVE OPERATION: Local access revocation"
    warn "This will make ALL encrypted content permanently unrecoverable!"
    warn "Even with master keys, the content will be lost."
    echo
    info "This operation will:"
    info "  ‚Ä¢ Remove local repository key"
    info "  ‚Ä¢ Remove master key references"
    info "  ‚Ä¢ Leave locker.age encrypted but unrecoverable"
    echo
    
    if [[ "$force" != "--force" ]]; then
        error "This operation requires --force flag to confirm"
        info "Usage: padlock revoke --local --force"
        return 1
    fi
    
    # Additional confirmation
    echo
    warn "‚ö†Ô∏è  FINAL WARNING: This will permanently destroy access to encrypted data"
    read -p "Type 'DESTROY' to confirm: " -r confirm
    if [[ "$confirm" != "DESTROY" ]]; then
        info "Revocation cancelled"
        return 0
    fi
    
    local revoked_items=()
    
    # Remove local repository key
    local repo_key="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
    if [[ -f "$repo_key" ]]; then
        rm -f "$repo_key"
        revoked_items+=("local repository key")
    fi
    
    # Remove master key reference from any config
    if [[ -f "$REPO_ROOT/locker/.padlock" ]]; then
        # If unlocked, remove master key from recipients
        source "$REPO_ROOT/locker/.padlock"
        if [[ -n "${AGE_RECIPIENTS:-}" ]]; then
            # Remove master key recipient
            local master_public
            if [[ -f "$PADLOCK_GLOBAL_KEY" ]]; then
                master_public=$(age-keygen -y "$PADLOCK_GLOBAL_KEY" 2>/dev/null || true)
                if [[ -n "$master_public" ]]; then
                    # Remove master key from recipients list
                    AGE_RECIPIENTS=$(echo "$AGE_RECIPIENTS" | sed "s/,$master_public//g" | sed "s/$master_public,//g" | sed "s/$master_public//g")
                    export AGE_RECIPIENTS
                    __print_padlock_config "$REPO_ROOT/locker/.padlock" "$(basename "$REPO_ROOT")"
                    revoked_items+=("master key access")
                fi
            fi
        fi
    fi
    
    # Remove from manifest
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        grep -v -F "$REPO_ROOT" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        revoked_items+=("manifest entry")
    fi
    
    # Create revocation marker
    cat > "$REPO_ROOT/.revoked" << EOF
# Padlock Access Revoked
# Generated: $(date)
# Repository: $(basename "$REPO_ROOT")

This repository's encryption keys have been revoked.
The encrypted content in locker.age is permanently unrecoverable.

Revoked access types:
$(printf "  ‚Ä¢ %s\n" "${revoked_items[@]}")

If this was done in error, restore from backup immediately.
EOF
    
    error "üîí Local access permanently revoked"
    if [[ ${#revoked_items[@]} -gt 0 ]]; then
        info "Revoked: ${revoked_items[*]}"
    fi
    warn "‚ö†Ô∏è  Encrypted content is now permanently unrecoverable"
    info "üíÄ Created .revoked file as marker"
}

# Revoke ignition access - removes ignition key system
_revoke_ignition_access() {
    local force="$1"
    
    REPO_ROOT="$(_get_repo_root .)"
    
    if [[ ! -d "$REPO_ROOT/.chest" ]]; then
        error "Repository is not using ignition system"
        info "Nothing to revoke"
        return 1
    fi
    
    lock "üî• Revoking ignition key access..."
    
    local revoked_items=()
    
    # Remove ignition key files
    if [[ -f "$REPO_ROOT/.chest/ignition.age" ]]; then
        rm -f "$REPO_ROOT/.chest/ignition.age"
        revoked_items+=("encrypted ignition key")
    fi
    
    # Remove any temporary ignition keys
    rm -f "$REPO_ROOT/.ignition.key"
    
    # If chest is unlocked, we need to transition to standard mode
    if [[ -d "$REPO_ROOT/locker" ]] && [[ -f "$REPO_ROOT/locker/.padlock" ]]; then
        info "Converting from ignition to standard mode..."
        
        # Generate new repository key
        local new_repo_key="$PADLOCK_KEYS/$(basename "$REPO_ROOT").key"
        age-keygen -o "$new_repo_key" >/dev/null
        chmod 600 "$new_repo_key"
        
        # Get new public key
        local new_public
        new_public=$(age-keygen -y "$new_repo_key")
        
        # Update configuration to standard mode with master key backup
        _ensure_master_key
        local master_public
        master_public=$(age-keygen -y "$PADLOCK_GLOBAL_KEY")
        
        export AGE_RECIPIENTS="$new_public,$master_public"
        export PADLOCK_KEY_FILE="$new_repo_key"
        export AGE_PASSPHRASE=""
        
        __print_padlock_config "$REPO_ROOT/locker/.padlock" "$(basename "$REPO_ROOT")"
        
        info "üîë Generated new repository key for standard mode"
        revoked_items+=("ignition system")
        revoked_items+=("converted to standard mode")
    fi
    
    # Remove chest directory if empty
    if [[ -d "$REPO_ROOT/.chest" ]] && [[ -z "$(ls -A "$REPO_ROOT/.chest" 2>/dev/null)" ]]; then
        rm -rf "$REPO_ROOT/.chest"
        revoked_items+=("chest directory")
    fi
    
    # Update manifest type
    local manifest_file="$PADLOCK_ETC/manifest.txt"
    if [[ -f "$manifest_file" ]]; then
        local temp_manifest
        temp_manifest=$(mktemp)
        # Change type from ignition to standard
        sed "s/|$REPO_ROOT|ignition|/|$REPO_ROOT|standard|/g" "$manifest_file" > "$temp_manifest" 2>/dev/null || true
        mv "$temp_manifest" "$manifest_file"
        trace "Updated manifest type to standard"
    fi
    
    okay "‚úì Ignition access revoked"
    if [[ ${#revoked_items[@]} -gt 0 ]]; then
        info "Changes: ${revoked_items[*]}"
    fi
    
    if [[ -d "$REPO_ROOT/locker" ]]; then
        info "üìù Repository is now in standard mode"
        info "üîê Re-encrypt with: padlock lock"
    else
        info "üîí Repository remains locked in standard mode"
        info "üîì Unlock with: padlock unlock"
    fi
}

# === 07_core.sh ===
dispatch() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        clamp)
            do_clamp "$@"
            ;;
        setup)
            do_setup "$@"
            ;;
        lock)
            do_lock "$@"
            ;;
        unlock)
            do_unlock "$@"
            ;;
        status)
            do_status "$@"
            ;;
        key)
            do_key "$@"
            ;;
        install)
            do_install "$@"
            ;;
        uninstall)
            do_uninstall "$@"
            ;;
        master-unlock)
            do_master_unlock "$@"
            ;;
        master)
            do_master "$@"
            ;;
        ignite)
            do_ignite "$@"
            ;;
        rotate)
            do_rotate "$@"
            ;;
        list)
            do_list "$@"
            ;;
        ls)
            do_ls "$@"
            ;;
        clean-manifest)
            do_clean_manifest "$@"
            ;;
        declamp)
            do_declamp "$@"
            ;;
        release)
            do_declamp "$@"  # Alias for declamp
            ;;
        map)
            do_map "$@"
            ;;
        sec)
            do_sec "$@"  # File security mini-dispatcher
            ;;
        automap)
            do_automap "$@"
            ;;
        autosec)
            do_automap "$@"  # Auto-secure (new name for automap)
            ;;
        unmap)
            do_unmap "$@"
            ;;
        dec)
            do_unmap "$@"  # De-secure file (new name for unmap)
            ;;
        path)
            do_path "$@"
            ;;
        remote)
            do_remote "$@"
            ;;
        revoke)
            do_revoke "$@"
            ;;
        repair)
            do_repair "$@"
            ;;

        export)
            do_export "$@"
            ;;
        import)
            do_import "$@"
            ;;
        snapshot)
            do_snapshot "$@"
            ;;
        rewind)
            do_rewind "$@"
            ;;

        overdrive)
            do_overdrive "$@"
            ;;

        help|--help|-h)
            case "${1:-}" in
                master)
                    help_master
                    ;;
                sec)
                    help_sec
                    ;;
                rotate)
                    help_rotate
                    ;;
                revoke)
                    help_revoke
                    ;;
                ignite)
                    help_ignite
                    ;;
                more)
                    usage_detailed
                    ;;
                "")
                    usage
                    ;;
                *)
                    error "No help available for: $1"
                    info "Available help topics: master, sec, rotate, revoke, ignite, more"
                    usage
                    ;;
            esac
            ;;
        version|--version|-v)
            _logo
            printf "padlock %s\n" "$PADLOCK_VERSION"
            printf "PADLOCK (c) 2025 Qodeninja for BASHFX\n"
            ;;
        dev_test)
            if is_dev; then
                dev_test "$@"
            else
                fatal "Dev command requires -D flag"
            fi
            ;;
        *)
            error "Unknown command: $cmd"
            info "Run 'padlock help' for available commands"
            return 1
            ;;
    esac
}

usage() {
    _logo
    cat << 'USAGE_EOF'
Padlock - Git Repository Security Orchestrator

USAGE:
    padlock <command> [options]

COMMANDS:
    clamp <path>     Deploy padlock to a git repository
      --global-key   Use or create global key
      --generate     Generate new repo-specific key
      --key <key>    Use explicit key
      -K, --ignition [key]  Enable ignition mode for AI collaboration

    # Daily Operations
    lock            Encrypt locker/ ‚Üí locker.age
    unlock          Decrypt locker.age ‚Üí locker/
    status          Show current lock/unlock state with next steps
    release <path>  Remove padlock from repository (same as declamp)

    # Master Key Management
    master          Master key operations
      generate       Generate new global master key
      show           Display master public key  
      restore        Restore master key from skull backup
      unlock         Emergency unlock using master key

    # Key Testing & Management
    key             Advanced key operations
      is <type> --key=PATH          Test if key is specific type
      authority --key1=X --key2=Y   Test authority relationship
      subject --key1=X --key2=Y     Test subject relationship
      type --key=/path              Identify key type
      --set-global <key>            Store global key (legacy)
      --show-global                 Display global key (legacy)

    # File Security
    sec             File security operations
      <path>         Secure file (default: add to mapping)
      add <path>     Add file to security mapping
      remove <path>  Remove file from security mapping  
      auto           Auto-secure sensitive files
    dec <path>      De-secure file (remove from mapping)

    # Access Management
    rotate          Rotate keys (requires predicate)
      master         Rotate global master key (affects all repos)
      ignition [name] Rotate ignition key (invalidates distributed keys)
      distro <name>  Rotate specific distributed key

    revoke          Revoke access (requires predicate)  
      ignition [name] Revoke ignition key
      distro <name>   Revoke specific distributed key

    # Ignition System (Third-Party Access)
    ignite          Ignition key operations
      create [name]  Create repo-ignition master key
      new --name=X   Create distributed key for third parties
      unlock [name]  Unlock using distributed key + PADLOCK_IGNITION_PASS
      allow <pubkey> Grant access to public key
      list           List ignition keys
      status         Show ignition system status

    install         Install padlock to your system for global access
    uninstall       Remove padlock from your system

    Manifest Management:
    list [--all|--ignition|--namespace <ns>]
                    List tracked repositories
    clean-manifest  Prune stale entries from the manifest

    Backup and Restore:
    export [file]   Export entire padlock environment to an encrypted file
    import <file>   Import an environment from an export file
    snapshot [name] Create a named backup snapshot of the current environment
    rewind <name>   Restore the environment from a named snapshot


    Advanced:
    map <path>      Map additional files/dirs for inclusion in chest
      add|remove    Add or remove path from mappings (default: add)
    automap         Automatically map common sensitive files and directories
                    (*.md files, build.sh, parts/, .claude, .gemini, .codex, .priv, .sec, *.local.*, *bak*)
    unmap <path|all> Remove files/dirs from mappings (with selection support)
    path [repo]     Show computed storage paths for keys and artifacts
    remote [repo]   Update artifacts for remote namespace (after adding git remote)
    overdrive       Engage overdrive mode (encrypts entire repo)
    declamp         Remove padlock from a repository
    revoke          Revoke encryption access (removes keys and forces re-key)
    repair          Repair missing padlock artifacts from manifest

    help            Show this help
    version         Show version

WORKFLOW:
    # Deploy to repository with ignition mode
    padlock clamp /path/to/repo -K

    # Work with secrets locally
    cd /path/to/repo
    echo "secret content" > locker/docs_sec/private.md

    # Commit (auto-encrypts)
    git add . && git commit -m "Add secrets"

    # Share ignition key for AI collaboration
    export PADLOCK_IGNITION_PASS="flame-rocket-boost-spark"
    source .locked

    # Emergency unlock if keys are lost
    padlock master-unlock

EXAMPLES:
    # Standard deployment
    padlock clamp . --generate

    # AI collaboration setup
    padlock clamp . -K "my-custom-ignition-key"

    # Emergency recovery
    padlock master-unlock

    # Check repository state
    padlock status

USAGE_EOF
}

options() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug)
                opt_debug=1
                trace "Debug mode enabled"
                shift
                ;;
            -t|--trace)
                opt_trace=1
                opt_debug=1  # Trace implies debug
                trace "Trace mode enabled"
                shift
                ;;
            -q|--quiet)
                opt_quiet=1
                shift
                ;;
            -f|--force)
                opt_force=1
                trace "Force mode enabled"
                shift
                ;;
            -y|--yes)
                opt_yes=1
                trace "Auto-yes mode enabled"
                shift
                ;;
            -D|--dev)
                opt_dev=1
                opt_debug=1
                opt_trace=1
                trace "Developer mode enabled"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                _logo
                printf "padlock %s\n" "$PADLOCK_VERSION"
                printf "PADLOCK (c) 2025 Qodeninja for BASHFX\n"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                error "Unknown option: $1"
                info "Use -h for help"
                exit 1
                ;;
            *)
                # Not an option, break to handle as command
                break
                ;;
        esac
    done

    # Return remaining arguments
    return 0
}

dev_test() {
    if ! is_dev; then
        fatal "dev_test requires developer mode (-D)"
    fi

    lock "üß™ Running developer tests..."

    # Test crypto functions
    info "Testing crypto stream functions..."
    local test_data="test encryption data"

    # Set up test crypto
    AGE_PASSPHRASE="test-passphrase-123"

    # Test encrypt/decrypt cycle
    local encrypted decrypted
    encrypted=$(echo "$test_data" | __encrypt_stream)
    decrypted=$(echo "$encrypted" | __decrypt_stream)

    if [[ "$decrypted" == "$test_data" ]]; then
        okay "Crypto stream test passed"
    else
        error "Crypto stream test failed"
        trace "Expected: $test_data"
        trace "Got: $decrypted"
    fi

    # Test guard functions
    info "Testing guard functions..."

    if is_dev; then
        okay "is_dev() test passed"
    else
        error "is_dev() test failed"
    fi

    # Test repo detection
    info "Testing repo detection..."

    if is_git_repo "."; then
        okay "Git repo detection passed"
    else
        warn "Not in a git repo (expected for isolated testing)"
    fi

    # Test XDG paths
    info "Testing XDG paths..."
    trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    trace "PADLOCK_ETC: $PADLOCK_ETC"
    trace "PADLOCK_KEYS: $PADLOCK_KEYS"

    okay "Developer tests completed"
}

# Simplified usage for AI efficiency
usage() {
    _logo
    cat << 'USAGE_SIMPLE_EOF'
Padlock - Git Repository Security Orchestrator

USAGE:
    padlock <command> [options]

CORE COMMANDS:
    clamp <path>        Deploy padlock to a git repository
    lock                Encrypt locker/ ‚Üí locker.age
    unlock              Decrypt locker.age ‚Üí locker/
    status              Show current lock/unlock state
    release <path>      Remove padlock from repository

MANAGEMENT:
    master <action>     Master key operations (generate/show/restore/unlock)
    sec <action>        File security operations (add/remove/auto)
    rotate <type>       Rotate keys (master/ignition/distro)
    revoke <type>       Revoke access (ignition/distro)

HELP:
    help more           Show detailed help with all options
    help <command>      Show help for specific command

EXAMPLES:
    padlock clamp . -K          # Deploy with ignition mode
    padlock status              # Check current state
    padlock help master         # Show master command help

USAGE_SIMPLE_EOF
}

# Detailed usage for human reference
usage_detailed() {
    _logo
    cat << 'USAGE_DETAILED_EOF'
Padlock - Git Repository Security Orchestrator

USAGE:
    padlock <command> [options]

COMMANDS:
    clamp <path>     Deploy padlock to a git repository
      --global-key   Use or create global key
      --generate     Generate new repo-specific key
      --key <key>    Use explicit key
      -K, --ignition [key]  Enable ignition mode for AI collaboration

    # Daily Operations
    lock            Encrypt locker/ ‚Üí locker.age
    unlock          Decrypt locker.age ‚Üí locker/
    status          Show current lock/unlock state with next steps
    release <path>  Remove padlock from repository (same as declamp)

    # Master Key Management
    master          Master key operations
      generate       Generate new global master key
      show           Display master public key  
      restore        Restore master key from skull backup
      unlock         Emergency unlock using master key

    # Key Testing & Management
    key             Advanced key operations
      is <type> --key=PATH          Test if key is specific type
      authority --key1=X --key2=Y   Test authority relationship
      subject --key1=X --key2=Y     Test subject relationship
      type --key=/path              Identify key type
      --set-global <key>            Store global key (legacy)
      --show-global                 Display global key (legacy)

    # File Security
    sec             File security operations
      <path>         Secure file (default: add to mapping)
      add <path>     Add file to security mapping
      remove <path>  Remove file from security mapping  
      auto           Auto-secure sensitive files
    dec <path>      De-secure file (remove from mapping)

    # Access Management
    rotate          Rotate keys (requires predicate)
      master         Rotate global master key (affects all repos)
      ignition [name] Rotate ignition key (invalidates distributed keys)
      distro <name>  Rotate specific distributed key

    revoke          Revoke access (requires predicate)  
      ignition [name] Revoke ignition key
      distro <name>   Revoke specific distributed key

    # Ignition System (Third-Party Access)
    ignite          Ignition key operations
      create [name]  Create repo-ignition master key
      new --name=X   Create distributed key for third parties
      unlock [name]  Unlock using distributed key + PADLOCK_IGNITION_PASS
      allow <pubkey> Grant access to public key
      list           List ignition keys
      status         Show ignition system status

    install         Install padlock to your system for global access
    uninstall       Remove padlock from your system

    Manifest Management:
    list [--all|--ignition|--namespace <ns>]
                    List tracked repositories
    clean-manifest  Prune stale entries from the manifest

    Backup and Restore:
    export [file]   Export entire padlock environment to an encrypted file
    import <file>   Import an environment from an export file
    snapshot [name] Create a named backup snapshot of the current environment
    rewind <name>   Restore the environment from a named snapshot


    Advanced:
    map <path>      Map additional files/dirs for inclusion in chest
      add|remove    Add or remove path from mappings (default: add)
    automap         Automatically map common sensitive files and directories
                    (*.md files, build.sh, parts/, .claude, .gemini, .codex, .priv, .sec, *.local.*, *bak*)
    unmap <path|all> Remove files/dirs from mappings (with selection support)
    path [repo]     Show computed storage paths for keys and artifacts
    remote [repo]   Update artifacts for remote namespace (after adding git remote)
    overdrive       Engage overdrive mode (encrypts entire repo)
    declamp         Remove padlock from a repository
    revoke          Revoke encryption access (removes keys and forces re-key)
    repair          Repair missing padlock artifacts from manifest

    help            Show simplified help
    help more       Show this detailed help
    help <command>  Show help for specific command
    version         Show version

WORKFLOW:
    # Deploy to repository with ignition mode
    padlock clamp /path/to/repo -K

    # Work with secrets locally
    cd /path/to/repo
    echo "secret content" > locker/docs_sec/private.md

    # Commit (auto-encrypts)
    git add . && git commit -m "Add secrets"

    # Share ignition key for AI collaboration
    export PADLOCK_IGNITION_PASS="flame-rocket-boost-spark"
    source .locked

    # Emergency unlock if keys are lost
    padlock master-unlock

EXAMPLES:
    # Standard deployment
    padlock clamp . --generate

    # AI collaboration setup
    padlock clamp . -K "my-custom-ignition-key"

    # Emergency recovery
    padlock master-unlock

    # Check repository state
    padlock status

USAGE_DETAILED_EOF
}

# Contextual help functions
help_master() {
    cat << 'HELP_MASTER_EOF'
MASTER KEY MANAGEMENT:

    padlock master <action> [options]

ACTIONS:
    generate        Generate new global master key
                   WARNING: Invalidates all existing repositories
                   
    show           Display master public key for sharing
                  Use for adding to new repositories
                  
    restore        Restore master key from skull backup
                  Emergency recovery option
                  
    unlock         Emergency unlock using master key
                  Last resort when repo keys are lost

EXAMPLES:
    padlock master generate     # Create new master key
    padlock master show        # Display public key
    padlock master unlock      # Emergency unlock

NOTES:
    Master key operations affect ALL repositories using padlock.
    Always backup before rotating master keys.
HELP_MASTER_EOF
}

help_sec() {
    cat << 'HELP_SEC_EOF'
FILE SECURITY OPERATIONS:

    padlock sec <action> [path]

ACTIONS:
    <path>         Secure file (default: add to mapping)
    add <path>     Add file to security mapping
    remove <path>  Remove file from security mapping
    auto           Auto-secure sensitive files
    
    # Alternative command:
    padlock dec <path>    # De-secure file (same as remove)

EXAMPLES:
    padlock sec config.json        # Secure a file
    padlock sec add *.key         # Secure key files
    padlock sec remove old.conf   # Remove from security
    padlock sec auto              # Auto-secure common files

AUTO-SECURE PATTERNS:
    *.md files, build.sh, parts/, .claude, .gemini, .codex, 
    .priv, .sec, *.local.*, *bak*

NOTES:
    Secured files are automatically included in chest encryption.
    Files are moved to .chest/ directory structure.
HELP_SEC_EOF
}

help_rotate() {
    cat << 'HELP_ROTATE_EOF'
KEY ROTATION OPERATIONS:

    padlock rotate <predicate> [name]

PREDICATES (REQUIRED):
    master         Rotate global master key
                  WARNING: Affects ALL repositories
                  
    ignition [name] Rotate ignition master key
                   Invalidates all distributed keys
                   
    distro <name>  Rotate specific distributed key
                  Affects only named distributed key

EXAMPLES:
    padlock rotate master              # Rotate master key
    padlock rotate ignition            # Rotate default ignition
    padlock rotate ignition myteam    # Rotate named ignition
    padlock rotate distro ai-key      # Rotate specific distributed key

NOTES:
    Rotation is a destructive operation requiring predicates for safety.
    Always ensure backup/recovery methods before rotating keys.
HELP_ROTATE_EOF
}

help_revoke() {
    cat << 'HELP_REVOKE_EOF'
ACCESS REVOCATION OPERATIONS:

    padlock revoke <predicate> [name]

PREDICATES (REQUIRED):
    ignition [name] Revoke ignition key access
                   Prevents distributed key creation
                   
    distro <name>  Revoke specific distributed key
                  Immediate access termination

EXAMPLES:
    padlock revoke ignition            # Revoke default ignition
    padlock revoke ignition myteam    # Revoke named ignition
    padlock revoke distro ai-key      # Revoke specific distributed key

NOTES:
    Revocation is immediate and permanent.
    Revoked keys cannot unlock existing encrypted content.
    Use rotate instead of revoke if you want to maintain access.
HELP_REVOKE_EOF
}

help_ignite() {
    cat << 'HELP_IGNITE_EOF'
IGNITION SYSTEM (Third-Party Access):

    padlock ignite <action> [options]

ACTIONS:
    create [name]  Create repo-ignition master key
    new --name=X   Create distributed key for third parties
    unlock [name]  Unlock using distributed key + PADLOCK_IGNITION_PASS
    allow <pubkey> Grant access to public key
    list           List ignition keys
    status         Show ignition system status

EXAMPLES:
    padlock ignite create              # Create ignition master
    padlock ignite new --name=ai       # Create distributed key
    padlock ignite unlock              # Unlock with passphrase
    padlock ignite status              # Check system status

ENVIRONMENT:
    PADLOCK_IGNITION_PASS    Passphrase for ignition unlock

NOTES:
    Ignition system enables secure third-party access.
    Distributed keys can be safely shared with AI systems.
    Ignition unlock requires both key and passphrase.
HELP_IGNITE_EOF
}

# === 08_main.sh ===
################################################################################
# Main Function - Primary Entrypoint
################################################################################

main() {
    local ret=0
    
    # Early environment checks
    if [[ "${BASH_VERSION%%.*}" -lt 4 ]]; then
        fatal "Bash 4.0+ required (found: $BASH_VERSION)"
    fi
    
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        usage
        return 0
    fi
    
    # Parse options first (modifies opt_* variables)
    options "$@"
    
    # Skip processed options to get to command
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--debug|-t|--trace|-q|--quiet|-f|--force|-y|--yes|-D|--dev)
                shift
                ;;
            -h|--help|-v|--version)
                # These are handled in options() and exit
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                shift  # Skip unknown options (already handled in options())
                ;;
            *)
                # Found command
                break
                ;;
        esac
    done
    
    # Show startup info in dev mode
    if is_dev; then
        trace "Padlock v$PADLOCK_VERSION starting..."
        trace "Script: $SCRIPT_PATH"
        trace "PID: $$"
        trace "Args: $*"
        trace "XDG_ETC_HOME: $XDG_ETC_HOME"
    fi
    
    # Dispatch to command handlers
    if [[ $# -gt 0 ]]; then
        dispatch "$@" || ret=$?
    else
        # No command provided after parsing options
        usage
    fi
    
    # Clean exit
    if is_dev; then
        trace "Padlock exiting with status: $ret"
    fi
    
    return $ret
}
# === 09_footer.sh ===
################################################################################
# Footer - Script Invocation
################################################################################

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
